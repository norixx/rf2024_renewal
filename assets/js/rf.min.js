(function () {
  'use strict';

  let rf_globals = {
    window_state: 'SP', // or PC
    breakpoint: 768,
  };

  const rf_set_globals = settings => {

    rf_globals = {
      ...rf_globals,
      ...settings,
    };
  };

  const rf_get_globals = key => {
    return rf_globals[key]
  };

  const rf_responsive_check = () => {
    window.addEventListener('resize', () => {
      requestAnimationFrame(() => {
        let current_state = rf_get_globals('window_state');

        if (window.innerWidth < rf_get_globals('breakpoint') && current_state === 'PC') {
          rf_set_globals({
            window_state: 'SP',
          });
          console.log('SP');
        } else if (window.innerWidth >= rf_get_globals('breakpoint') && current_state === 'SP') {
          rf_set_globals({
            window_state: 'PC',
          });
          console.log('PC');
        }

      });
    });

    // 初動
    window.dispatchEvent(new Event('resize'));
  };

  const rf_gnav = () => {
    let _isOpen = false; //グローバルナビゲーションの開閉状態
    let _isOpenSub = false; // PC用 - のLv2のナビゲーションの開閉状態
    let _current = null; // 現在開いているLv1のID
    let _currentSub = null; // PC用 - 現在開いているLv2のID
    const gnavID = 'gnav-main';
    const openClass = '--is-open';
    const lv1Flag = 'jsGnavLv1'; // Lv1のナビゲーションのフラグ(dataset名)
    // const gnavBtnPC = document.querySelectorAll('[data-js-gnav-pc]')
    const gnav = document.querySelector(`#${gnavID}`); //グローバルナビゲーション本体
    const gnavBtn = document.querySelector('#gnav-btn-open');
    const gnavBtnClose = document.querySelector('[data-js-gnav-close]');
    const gnavSubContainer = document.querySelector('#gnav-sub-container');
    const gnavBtnSubContClose = document.querySelector('[data-js-gnav-sub-container-close]');
    const gnavToggles = document.querySelectorAll('[data-js-gnav-sub]');
    const gnavToggleTargets = Array.from(gnavToggles).map(toggle => document.querySelector(toggle.dataset.jsGnavSub));
    const gnavClose = document.querySelectorAll(['[data-js-gnav-sub-close]']);

    // Gnavを閉じる + すべてを閉じる
    const _hideGnav = () => {
      _isOpen = false;
      gnav.classList.remove(openClass);

      // PC サブコンテナを閉じる
      _isOpenSub = false;
      _current = null;
      _currentSub = null;
      gnavSubContainer.classList.remove(openClass);


      // openClassを全て削除
      gnavToggles.forEach(target => {
        target.classList.remove(openClass);
      });
      gnavToggleTargets.forEach(target => {
        target.classList.remove(openClass);
      });

    };

    // Gnavを開く
    const _showGnav = () => {
      _isOpen = true;
      gnav.classList.add(openClass);
    };

    // SP - Gnav(自体)をタップしたら閉じる
    gnav.addEventListener('click', e => {
      const target = e.target;
      // console.log(target.id)
      if (target.id !== gnavID) return
      _hideGnav();
    });

    // SP - Gnavを閉じるボタン
    gnavBtnClose.addEventListener('click', e => {
      _hideGnav();
    });

    // SP - Gnav🍔
    gnavBtn.addEventListener('click', e => {
      if (_isOpen && gnav.classList.contains(openClass)) {
        _hideGnav();
      } else {
        _showGnav();
      }
    });

    // Gnav Toggles
    gnavToggles.forEach(toggle => {
      toggle.addEventListener('click', e => {
        console.log('クリック前のLv2: ', _currentSub);
        const targetID = toggle.dataset.jsGnavSub;

        // PC - Lv1部分をクリックした場合
        if (lv1Flag in toggle.dataset && rf_get_globals('window_state') === 'PC') {
          console.log('PC Lv1 クリック: ', targetID);

          // ▼ サブコンテナ制御
          // 1. 開いている + 同じ => 閉じる
          if (_isOpenSub && _currentSub === targetID) {
            console.log('PC サブコンテナ閉じる');
            _hideGnav();

            return //処理は中止
          }
          // 2. 開いている + 違う => 切り替える（開く）
          if (_isOpenSub && _currentSub !== targetID) {
            console.log('PC サブコンテナ切り替え');

            // 1つ前のサブコンテナ
            document.querySelector(_currentSub).classList.remove(openClass);
          }

          // 3. 開いていない => 開く
          if (_isOpenSub === false) {
            _showGnav(); // Gnavを開く(SP用だけど一応実行)
            gnavSubContainer.classList.add(openClass); //サブコンテナを開く
            _isOpenSub = true;
          }
        }

        _currentSub = targetID;

        console.log('クリック後のLv2: ', _currentSub);
        console.log(_isOpenSub);

        // SP - Lv1部分をクリックした場合でも一応サブコンテナを開く
        if (
          lv1Flag in toggle.dataset &&
          _isOpenSub !== true &&
          rf_get_globals('window_state') === 'SP'
        ) {
          gnavSubContainer.classList.add(openClass); //サブコンテナを開く
          _isOpenSub = true;
        }

        // PC & SP - ターゲットのopenClassをトグル
        document.querySelector(targetID).classList.add(openClass);

        // PC & SP - Lv1を更新
        if (lv1Flag in toggle.dataset) {
          // 1つ前のLv1リンクからopenClassを削除し、新しいものへ追加
          const _prev = document.querySelector(`[data-js-gnav-lv1=${_current}]`);
          console.log('1つ前のLv1', _prev);
          if (_prev) {
            _prev.classList.remove(openClass);
          }

          _current = toggle.dataset[lv1Flag];
          console.log('保存したLv1', _current);
          toggle.classList.add(openClass);
        }
      });
    });

    // PC - サブコンテナを閉じる
    gnavBtnSubContClose.addEventListener('click', () => {
      _hideGnav();
    });

    // SP - サブナビゲーションを閉じる
    gnavClose.forEach(close => {
      close.addEventListener('click', () => {
        const target = document.querySelector(close.dataset.jsGnavSubClose);
        if (target.classList.contains(openClass)) target.classList.remove(openClass);
      });
    });


  };

  // Toggle 共通

  const rf_toggles = () => {
    const toggles = document.querySelectorAll('[data-js-toggle]');
    const toggleSPClass = 'toggle-sp-only';
    const togglePCClass = 'toggle-pc-only';
    const toggleClass = '--is-open';

    const setToggleControl = () => {
      toggles.forEach(toggle => {
        const target = document.querySelector(toggle.dataset.jsToggle);
        // 初動 - トグルボタンに--is-openがついていればターゲットにも追加
        if (toggle.classList.contains(toggleClass) && !target.classList.contains(toggleClass)) {
          target.classList.add(toggleClass);
        }

        // レスポンシブチェック
        toggle.addEventListener('click', e => {
          // const self = e.target
          // SP
          if (toggle.classList.contains(toggleSPClass) && rf_get_globals('window_state') !== 'SP') {
            return
          }
          // PC
          if (toggle.classList.contains(togglePCClass) && rf_get_globals('window_state') !== 'PC') {
            return
          }
          toggle.classList.toggle(toggleClass);
          // const target = document.querySelector(toggle.dataset.toggle)
          target.classList.toggle(toggleClass);
        });
      });
    };

    const init = () => {
      setToggleControl();
    };

    init();

  };

  // TOPバナースライダー
  const rf_top_banners = () => {
    const args = {
      breakpoints: {
        0: {
          slidesPerView: 1.3,
          spaceBetween: 16,
          slidesOffsetAfter: 16,
          slidesOffsetBefore: 16,
        },
        768: {
          slidesPerView: 4.3,
          spaceBetween: 24,
          slidesOffsetAfter: 24,
          slidesOffsetBefore: 24,
        },
      },
    };

    const setSwiper = () => {
      new Swiper('[data-js-top-banners]', args);
    };

    const init = () => {
      setSwiper();
    };

    init();

  };

  const rf_todays_count = () => {
    const fetchURL = '/rf/today/';
    const target = document.querySelector('[data-js-today-target]');
    // const elementClass = '.c-top-search__prop-status-list'
    const dataID = '#todays-data';
    const targetElements = target.querySelectorAll('[data-js-today]');
    const errorMsg = '件数取得エラーが発生しました';
    // const loader = target.querySelector('[data-js-loader]')

    const errorHandler = err => {
      console.error(err);
      target.insertAdjacentHTML('beforeend', `<p class="u-color-alert u-fz-14 u-ta-center">${errorMsg}</p>`);
    };

    const insertContent = html => {
      const domParser = new DOMParser();
      const htmlElement = domParser.parseFromString(html, "text/html");
      // console.log(htmlElement)
      // const contents = htmlElement.querySelectorAll(elementClass)
      const data = JSON.parse(htmlElement.querySelector(dataID).textContent);
      console.log(data);
      // loader.remove()
      targetElements.forEach(element => {
        element.textContent = data[element.dataset.jsToday];
      });
      // contents.forEach(content => {
      //   target.insertAdjacentElement('beforeend', content)
      // })
    };

    // IDEA: https://stackoverflow.com/a/50812705
    const fetchContent = async () => {
      try {
        const response = await fetch(fetchURL);
        if (response.ok && response.status !== 404) {
          const html = await response.text();
          // console.log(html)
          insertContent(html);
        } else {
          throw new Error('fetch error')
        }

      } catch (err) {
        errorHandler(err);
      }
    };
    const init = async () => {
      fetchContent();
    };

    init();
  };

  // 物件スライダー
  const rf_prop_slider = () => {
    const propSliders = document.querySelectorAll('[data-js-prop-slider]');
    let sliders = {};

    const args = {
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
      },
      pagination: {
        el: ".c-prop-slider__pagination",
        type: "progressbar",
      },
      breakpoints: {
        0: {
          spaceBetween: 16,
          slidesPerView: 1.2,
          slidesOffsetBefore: 32,
          slidesOffsetAfter: 32,
        },
        768: {
          spaceBetween: 24,
          slidesPerView: 4.4,
          slidesOffsetBefore: 40,
          slidesOffsetAfter: 40,
        },
      },
    };

    const setSwiper = () => {
      propSliders.forEach(slider => {
        const propSlider = new Swiper(slider, args);
        sliders[slider.id] = propSlider;
      });
    };

    const init = () => {
      setSwiper();
    };

    init();

  };

  // お部屋リスト


  // 部屋リストリンク
  const rf_room_list_link = () => {
    const links = document.querySelectorAll('[data-js-room-link]');

    links.forEach(link => {
      link.addEventListener('click', e => {
        e.stopPropagation();
        const clicked = e.target;

        if (clicked.tagName === 'A' || clicked.tagName === 'BUTTON') {
          console.log('インタラクティブ要素なので中止');
          return
        }

        const target = link.dataset.jsRoomLink;
        window.open(target, '_blank');
      });
    });
  };

  // お部屋リストの制御
  const rf_room_list_toggle = () => {
    const openClass = '--is-open';
    let tempText = '';
    const maxHeightPC = 660;
    const maxHeightSP = 1200;
    const toggles = document.querySelectorAll('[data-js-room-toggle]');


    // トグルボタンのコントロール, 画像の読み込みなどを考慮してwindowロード後
    window.addEventListener('load', () => {
      toggles.forEach(toggle => {
        const target = document.querySelector(toggle.dataset.jsRoomToggle);

        // トグルボタンの表示・非表示をまず決める（デフォルト: 表示）
        if (rf_get_globals('window_state') === 'PC' && target.scrollHeight < maxHeightPC) {
          toggle.classList.add('--is-hide');
        } else if (rf_get_globals('window_state') === 'SP' && target.scrollHeight < maxHeightSP) {
          toggle.classList.add('--is-hide');
        }

        // クリックコントロール
        toggle.addEventListener('click', () => {

          target.classList.toggle(openClass);
          toggle.classList.toggle(openClass);

          // 高さ
          if (target.classList.contains(openClass)) {
            target.style.maxHeight = target.scrollHeight + 'px';
          } else {
            target.style.maxHeight = null;
          }


          // テキスト
          if ('jsRoomToggleText' in toggle.dataset) {
            tempText = toggle.textContent;
            toggle.textContent = toggle.dataset.jsRoomToggleText;
            toggle.dataset.jsRoomToggleText = tempText;
          }
        });
      });
    });

  };

  // 建物・部屋 共通

  const rf_buildroom_main_slide = () => {
    const mv_thumbs_args = {
      spaceBetween: 8,
      freeMode: true,
      watchSlidesProgress: true,
      breakpoints: {
        0: {
          slidesPerView: 4.5,
        },
        768: {
          slidesPerView: 8.5,
        },
      },
    };
    const mv_thumbs = new Swiper('[data-js-buildroom-mv-thumbs]', mv_thumbs_args);

    const mv_args = {
      pagination: {
        el: ".swiper-pagination",
        type: "fraction",
      },
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
      },
      thumbs: {
        swiper: mv_thumbs,
      },
    };
    new Swiper('[data-js-buildroom-mv]', mv_args);
  };

  const rf_modals = () => {
    const modalOpenHtmlClass = '--is-modal-open';
    const modalOpenClass = '--is-open';
    const html = document.documentElement;
    // const modalClass = 'c-modal'
    // const modals = document.querySelectorAll('.' + modalClass)
    const modals = document.querySelectorAll('[data-js-modal-target]');
    const modalOpenBtns = document.querySelectorAll('[data-js-modal]');
    const modalTargetName = 'jsModalTarget';
    // const modalCloseBtns = document.querySelectorAll('[data-js-modal-close]')
    let openedModals = [];

    // 開くボタン
    const setOpenModalBtns = () => {
      modalOpenBtns.forEach(btn => {
        const modalId = btn.dataset.jsModal;
        const targetModal = document.querySelector(modalId);

        btn.addEventListener('click', e => {
          if (btn.tagName === 'A') {
            e.preventDefault();
          }
          targetModal.classList.add(modalOpenClass);
          html.classList.add(modalOpenHtmlClass);
          openedModals.push(modalId);
        });
      });
    };

    // モーダル閉じるアクション
    const _closeModal = (modal) => {
      // console.log('モーダル閉じる, openedModalsは?', openedModals)
      console.log(modal.id);
      const index = openedModals.indexOf(modal);
      openedModals.splice(index, 1);
      // console.log('モーダル閉じたあと, openedModalsは?', openedModals)
      modal.classList.remove(modalOpenClass);
      if (openedModals.length === 0) {
        html.classList.remove(modalOpenHtmlClass);
      }
    };

    // モーダル制御
    const setModals = () => {
      modals.forEach(modal => {
        // モーダル本体閉じる
        modal.addEventListener('click', e => {
          if (modalTargetName in e.target.dataset) {
            console.log('モーダルターゲット');
            _closeModal(modal);
          }
        });

        // モーダル閉じるボタン
        const modalCloses = modal.querySelectorAll('[data-js-modal-close]');
        modalCloses.forEach(close => {
          close.addEventListener('click', () => {
            _closeModal(modal);
          });
        });

      });
    };

    const init = () => {
      setOpenModalBtns();
      setModals();
    };

    init();
  };

  // CTAナビ
  const rf_cta_navi_tel = () => {
    // const nav = document.querySelector('.c-cta-navi-tel');
    const btn = document.querySelector(['[data-js-cta-navi-tel]']);
    const nav = document.querySelector(btn.dataset.jsCtaNaviTel);

    btn.addEventListener('click', () => {
      nav.classList.toggle('--is-open');
    });
  };

  const rf_select_link = () => {

    const selectLinks = document.querySelectorAll('[data-js-select-link]');

    selectLinks.forEach(link => {
      link.addEventListener('change', e => {
        const href = e.target.selectedOptions[0].value;
        location.href = href;
      });
    });
  };

  // 関連物件スライダー
  const rf_related_prop_slider = () => {
    const relatedPropSliders = document.querySelectorAll('[data-js-related-prop-slider]');
    const sliders = [];
    const args = {
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
      },
      pagination: {
        el: ".c-prop-slider__pagination",
        type: "progressbar",
      },
      init: false, //あとで発動
      breakpoints: {
        0: {
          spaceBetween: 16,
          slidesPerView: 1.4,
          slidesOffsetBefore: 32,
          slidesOffsetAfter: 32,
        },
        768: {
          spaceBetween: 24,
          slidesPerView: 3.5,
          slidesOffsetBefore: 40,
          slidesOffsetAfter: 40,
        },
      },
    };

    // Swiper設定
    const setSwiper = () => {
      relatedPropSliders.forEach(slider => {
        const relatedPropSlider = new Swiper(slider, args);
        console.dir(relatedPropSlider);
        sliders.push(relatedPropSlider);
      });
      onLoaded();
    };

    // ロード完了アクション
    const onLoaded = () => {
      sliders.forEach(slider => {
        slider.on('init', () => {
          //ローダーを削除
          const loader = slider.el.querySelector('.c-prop-slider__loader');
          if (loader) {
            loader.remove();
          }
        });
        slider.init();
      });
    };

    const init = () => {
      setSwiper();
    };

    init();
  };

  const rf_ward = () => {
    const dataProp = 'jsWardSelect';
    document.querySelector('#sys-form');
    const btns = Array.from(document.querySelectorAll('[data-js-ward-select]'));
    const checkBoxes = btns.filter(btn => btn.tagName === 'INPUT');
    const boundaries = btns.filter(btn => btn.tagName === 'g');
    let currentWards = [];
    let selectedWards = [];
    const toggleClass = '--is-active';

    // 現在選択中の区
    const getWards = () => {
      return selectedWards
    };

    // １つの区
    // const getWard = ward => {

    // }

    const removeWard = ward => {
      const index = selectedWards.indexOf(ward);
      selectedWards.splice(index, 1);
      console.log('削除後', selectedWards);
    };

    // セット
    const setWard = ward => {
      selectedWards.push(ward);
    };

    // 現在の区
    const getCurrentWards = () => {
      return currentWards
    };
    const setCurrentWards = wards => {
      currentWards = [...wards];
      console.log('前の区', currentWards);
    };


    // チェックボックスのトグル
    const toggleCheckbox = (isAdd, dom) => {
      // 差分チェック
      let differences = null;
      if (isAdd) {
        differences = getWards().filter(element => !(getCurrentWards().includes(element)));
      } else {
        differences = getCurrentWards().filter(element => !(getWards().includes(element)));
      }
      console.log('差分', differences);

      //要素チェック
      const isCheckbox = (dom.tagName === 'INPUT');
      console.log('checkbox?', isCheckbox);

      differences.forEach(diff => {
        console.log('差分', diff);
        const [selectedBoundary] = boundaries.filter(bound => bound.dataset[dataProp] === diff);
        const [selectedCheckbox] = checkBoxes.filter(checkbox => checkbox.dataset[dataProp] === diff);
        console.log('選択された', selectedBoundary, selectedCheckbox);
        selectedBoundary.classList.toggle(toggleClass, isAdd);
        selectedCheckbox.checked = isAdd;
      });
    };

    const setToggleAction = () => {
      btns.forEach(btn => {
        btn.addEventListener('click', () => {
          let isAdd = true; // true or false
          setCurrentWards(getWards()); //現在の区を一旦保存
          const ward = btn.dataset.jsWardSelect;
          if (getWards().includes(ward)) {
            console.log('削除');
            isAdd = false;
            removeWard(ward);
          } else {
            console.log('追加');
            setWard(ward);
          }
          console.log('現在', selectedWards);
          console.log('１個前', currentWards);

          // 地図クリックの場合チェックボックスをトグル
          toggleCheckbox(isAdd, btn);
        });
      });
    };

    // すべてのチェックを外す - 画面戻ったときの対策
    const clearAllCheckboxes = () => {
      btns.forEach(btn => {
        console.dir(btn);
        if (btn.tagName === 'INPUT') {
          console.log(btn.checked);
          console.log(btn.defaultChecked);
          btn.setAttribute('autocomplete', 'off');
          btn.checked = false;
        }
      });
    };

    const init = () => {
      // resetForm()
      clearAllCheckboxes();
      // window.addEventListener('load', () => {
      //   console.log('loaded!')
      // })
      setToggleAction();
    };

    init();
  };

  // import rf_globals from './partials/_globals';

  // =======================================================
  // Inits

  // Viewport checker (SP or PC)
  rf_responsive_check();

  // Global Navigation
  if (document.querySelector('[data-js-gnav]')) {
    rf_gnav();
  }

  // Toggles
  if (document.querySelector('[data-js-toggle]')) {
    rf_toggles();
  }

  // TOPページ - 本日掲載
  if (document.querySelector('[data-js-today-target]')) {
    rf_todays_count();
  }

  // Topページ - バナー
  if (document.querySelector('[data-js-top-banners]')) {
    rf_top_banners();
  }

  // 物件スライダー(TOPページ)
  if (document.querySelector('[data-js-prop-slider]')) {
    rf_prop_slider();
  }

  // 物件スライダー(関連）
  if (document.querySelector('[data-js-related-prop-slider]')) {
    rf_related_prop_slider();
  }

  // お部屋リストリンク
  if (document.querySelector('[data-js-room-link]')) {
    rf_room_list_link();
    rf_room_list_toggle();
  }

  // 建物・部屋共通
  if (document.querySelector('[data-js-buildroom-mv]')) {
    rf_buildroom_main_slide();
  }
  if (document.querySelector('[data-js-buildroom-mv-thumbs]')) ;

  // モーダル
  if (document.querySelector('[data-js-modal]')) {
    rf_modals();
  }

  // CTAナビ
  if (document.querySelector('[data-js-cta-navi-tel]')) {
    rf_cta_navi_tel();
  }

  // セレクトリンク
  if (document.querySelector('[data-js-select-link]')) {
    rf_select_link();
  }

  // 区の選択
  if (document.querySelector(`[data-js-ward-select]`)) {
    rf_ward();
  }

})();
//# sourceMappingURL=rf.min.js.map
