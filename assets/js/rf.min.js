(function () {
  'use strict';

  // グローバル設定
  window.RF_GLOBALS = {};
  window.RF_GLOBALS.RF_CONFIG = {
    window_state: 'PC',
    breakpoint: 768,
  };

  const rf_set_globals = settings => {
    window.RF_GLOBALS.RF_CONFIG = {
      ...window.RF_GLOBALS.RF_CONFIG,
      ...settings,
    };
  };

  const rf_get_globals = key => {
    return RF_GLOBALS['RF_CONFIG'][key]
  };

  const rf_responsive_check = () => {
    window.addEventListener('resize', () => {
      requestAnimationFrame(() => {
        let current_state = rf_get_globals('window_state');

        if (window.innerWidth < rf_get_globals('breakpoint') && current_state === 'PC') {
          rf_set_globals({
            window_state: 'SP',
          });
          console.log('set to SP');
        } else if (window.innerWidth >= rf_get_globals('breakpoint') && current_state === 'SP') {
          rf_set_globals({
            window_state: 'PC',
          });
          console.log('set to PC');
        }
      });

    });

    // 初動
    window.dispatchEvent(new Event('resize'));
  };

  // ローダー
  /**
   * ローダー
   * @param {string} target - ローダーを挿入するターゲット（指定がなければbody）
   * @param {string} msg - ローダーのメッセージ（キャプション） default: 'Loading...'
   * @param {string} size - ローダーのサイズ（スタイルシートを参照） default: 'md'
   * @param {string} style - ローダーのスタイル（スタイルシートを参照） default: '--bg-black'
   */
  class RfLoader {
    #settings = {
      target: document.body,
      msg: 'Loading...',
      size: 'md',
      style: '--bg-black',
      loaderClass: 'c-loader',
      loader: null,
    }
    constructor(target, msg, size, style) {
      if (target) this.#settings.target = target;
      if (msg) this.#settings.msg = msg;
      if (size) this.#settings.size = size;
      if (style) this.#settings.style = style;
      console.log(this.#settings);
      this.#init();
    }

    #insertLoader(loader) {
      this.#settings.target.insertAdjacentHTML('beforeend', loader);
      this.#settings.loader = this.#settings.target.querySelector('.' + this.#settings.loaderClass); //ローダー要素を保管
      console.log(this.#settings.loader);
    }

    removeLoader() {
      // console.log('ローダーを削除')
      this.#settings.loader.remove();
    }

    #makeLoader() {
      let size = '';
      if (this.#settings.size !== 'md') size = `--${this.#settings.size}`;
      const loader = `<div class="${this.#settings.loaderClass} ${this.#settings.style} ${size}"></div>`;
      this.#insertLoader(loader);
    }

    #init() {
      this.#makeLoader();
    }
  }

  /**
   * Checkbox Status
   * @param {HTMLFormElement} form
   * @param {HTMLInputElement[]} checkboxes
   */
  class RfCheckboxStatus {
    #form;
    #checkboxes;
    #validator = {
      get(target, key) {
        console.log("target&key: ", target, key);
        const status = Array.prototype.slice
          .call(target["elements"])
          .some((x) => x.checked);
        console.log(target["elements"]);
        console.log(status);
        target[key] = status;
        return target[key];
      }
    };
    #checkBoxObj = {
      status: null,
      elements: null
    };
    #store;
    // #cb

    constructor(form, checkboxes) {
      if (!form || !checkboxes) throw new Error("No Form selected!");
      console.log("yes checkboxes!");
      this.#form = form;
      this.#checkboxes = checkboxes;
      this.#checkBoxObj["elements"] = this.#checkboxes;
      this.#store = new Proxy(this.#checkBoxObj, this.#validator);
      // this.#cb = cb
    }


    getStatus() {
      return this.#store.status;
    }
  }

  const rf_gnav = () => {
    let _isOpen = false; //グローバルナビゲーションの開閉状態
    let _isOpenSub = false; // PC用 - のLv2のナビゲーションの開閉状態
    let _current = null; // 現在開いているLv1のID
    let _currentSub = null; // PC用 - 現在開いているLv2のID
    const gnavID = 'gnav-main';
    const openClass = '--is-open';
    const lv1Flag = 'jsGnavLv1'; // Lv1のナビゲーションのフラグ(dataset名)
    // const gnavBtnPC = document.querySelectorAll('[data-js-gnav-pc]')
    const gnav = document.querySelector(`#${gnavID}`); //グローバルナビゲーション本体
    const gnavBtn = document.querySelector('#gnav-btn-open');
    const gnavBtnClose = document.querySelector('[data-js-gnav-close]');
    const gnavSubContainer = document.querySelector('#gnav-sub-container');
    const gnavBtnSubContClose = document.querySelector('[data-js-gnav-sub-container-close]');
    const gnavToggles = document.querySelectorAll('[data-js-gnav-sub]');
    const gnavToggleTargets = Array.from(gnavToggles).map(toggle => document.querySelector(toggle.dataset.jsGnavSub));
    const gnavClose = document.querySelectorAll(['[data-js-gnav-sub-close]']);

    // Gnavを閉じる + すべてを閉じる
    const _hideGnav = () => {
      _isOpen = false;
      gnav.classList.remove(openClass);

      // PC サブコンテナを閉じる
      _isOpenSub = false;
      _current = null;
      _currentSub = null;
      gnavSubContainer.classList.remove(openClass);


      // openClassを全て削除
      gnavToggles.forEach(target => {
        target.classList.remove(openClass);
      });
      gnavToggleTargets.forEach(target => {
        target.classList.remove(openClass);
      });

    };

    // Gnavを開く
    const _showGnav = () => {
      _isOpen = true;
      gnav.classList.add(openClass);
    };

    // SP - Gnav(自体)をタップしたら閉じる
    gnav.addEventListener('click', e => {
      const target = e.target;
      // console.log(target.id)
      if (target.id !== gnavID) return
      _hideGnav();
    });

    // SP - Gnavを閉じるボタン
    gnavBtnClose.addEventListener('click', e => {
      _hideGnav();
    });

    // SP - Gnav🍔
    gnavBtn.addEventListener('click', e => {
      if (_isOpen && gnav.classList.contains(openClass)) {
        _hideGnav();
      } else {
        _showGnav();
      }
    });

    // Gnav Toggles
    gnavToggles.forEach(toggle => {
      toggle.addEventListener('click', e => {
        console.log('クリック前のLv2: ', _currentSub);
        const targetID = toggle.dataset.jsGnavSub;

        // PC - Lv1部分をクリックした場合
        if (lv1Flag in toggle.dataset && rf_get_globals('window_state') === 'PC') {
          console.log('PC Lv1 クリック: ', targetID);

          // ▼ サブコンテナ制御
          // 1. 開いている + 同じ => 閉じる
          if (_isOpenSub && _currentSub === targetID) {
            console.log('PC サブコンテナ閉じる');
            _hideGnav();

            return //処理は中止
          }
          // 2. 開いている + 違う => 切り替える（開く）
          if (_isOpenSub && _currentSub !== targetID) {
            console.log('PC サブコンテナ切り替え');

            // 1つ前のサブコンテナ
            document.querySelector(_currentSub).classList.remove(openClass);
          }

          // 3. 開いていない => 開く
          if (_isOpenSub === false) {
            _showGnav(); // Gnavを開く(SP用だけど一応実行)
            gnavSubContainer.classList.add(openClass); //サブコンテナを開く
            _isOpenSub = true;
          }
        }

        _currentSub = targetID;

        console.log('クリック後のLv2: ', _currentSub);
        console.log(_isOpenSub);

        // SP - Lv1部分をクリックした場合でも一応サブコンテナを開く
        if (
          lv1Flag in toggle.dataset &&
          _isOpenSub !== true &&
          rf_get_globals('window_state') === 'SP'
        ) {
          gnavSubContainer.classList.add(openClass); //サブコンテナを開く
          _isOpenSub = true;
        }

        // PC & SP - ターゲットのopenClassをトグル
        document.querySelector(targetID).classList.add(openClass);

        // PC & SP - Lv1を更新
        if (lv1Flag in toggle.dataset) {
          // 1つ前のLv1リンクからopenClassを削除し、新しいものへ追加
          const _prev = document.querySelector(`[data-js-gnav-lv1=${_current}]`);
          console.log('1つ前のLv1', _prev);
          if (_prev) {
            _prev.classList.remove(openClass);
          }

          _current = toggle.dataset[lv1Flag];
          console.log('保存したLv1', _current);
          toggle.classList.add(openClass);
        }
      });
    });

    // PC - サブコンテナを閉じる
    gnavBtnSubContClose.addEventListener('click', () => {
      _hideGnav();
    });

    // SP - サブナビゲーションを閉じる
    gnavClose.forEach(close => {
      close.addEventListener('click', () => {
        const target = document.querySelector(close.dataset.jsGnavSubClose);
        if (target.classList.contains(openClass)) target.classList.remove(openClass);
      });
    });


  };

  // Toggle 共通

  const rf_toggles = () => {
    const toggles = document.querySelectorAll('[data-js-toggle]');
    const toggleSPClass = 'toggle-sp-only';
    const togglePCClass = 'toggle-pc-only';
    const toggleClass = '--is-open';

    const setToggleControl = () => {
      toggles.forEach(toggle => {
        const target = document.querySelector(toggle.dataset.jsToggle);
        // 初動 - トグルボタンに--is-openがついていればターゲットにも追加
        if (toggle.classList.contains(toggleClass) && !target.classList.contains(toggleClass)) {
          target.classList.add(toggleClass);
        }

        // レスポンシブチェック
        toggle.addEventListener('click', e => {
          // const self = e.target
          // SP
          if (toggle.classList.contains(toggleSPClass) && rf_get_globals('window_state') !== 'SP') {
            return
          }
          // PC
          if (toggle.classList.contains(togglePCClass) && rf_get_globals('window_state') !== 'PC') {
            return
          }
          toggle.classList.toggle(toggleClass);
          // const target = document.querySelector(toggle.dataset.toggle)
          target.classList.toggle(toggleClass);
        });
      });
    };

    const init = () => {
      setToggleControl();
    };

    init();

  };

  // TOPバナースライダー
  const rf_top_banners = () => {
    const args = {
      breakpoints: {
        0: {
          slidesPerView: 1.3,
          spaceBetween: 16,
          slidesOffsetAfter: 16,
          slidesOffsetBefore: 16,
        },
        768: {
          slidesPerView: 4.3,
          spaceBetween: 24,
          slidesOffsetAfter: 24,
          slidesOffsetBefore: 24,
        },
      },
    };

    const setSwiper = () => {
      new Swiper('[data-js-top-banners]', args);
    };

    const init = () => {
      setSwiper();
    };

    init();

  };

  const rf_todays_count = () => {
    const fetchURL = '/rf/today/';
    const target = document.querySelector('[data-js-today-target]');
    // const elementClass = '.c-top-search__prop-status-list'
    const dataID = '#todays-data';
    const targetElements = target.querySelectorAll('[data-js-today]');
    const errorMsg = '件数取得エラーが発生しました';
    // const loader = target.querySelector('[data-js-loader]')

    const errorHandler = err => {
      console.error(err);
      target.insertAdjacentHTML('beforeend', `<p class="u-color-alert u-fz-14 u-ta-center">${errorMsg}</p>`);
    };

    const insertContent = html => {
      const domParser = new DOMParser();
      const htmlElement = domParser.parseFromString(html, "text/html");
      // console.log(htmlElement)
      // const contents = htmlElement.querySelectorAll(elementClass)
      const data = JSON.parse(htmlElement.querySelector(dataID).textContent);
      console.log(data);
      // loader.remove()
      targetElements.forEach(element => {
        element.textContent = data[element.dataset.jsToday];
      });
      // contents.forEach(content => {
      //   target.insertAdjacentElement('beforeend', content)
      // })
    };

    // IDEA: https://stackoverflow.com/a/50812705
    const fetchContent = async () => {
      try {
        const response = await fetch(fetchURL);
        if (response.ok && response.status !== 404) {
          const html = await response.text();
          // console.log(html)
          insertContent(html);
        } else {
          throw new Error('fetch error')
        }

      } catch (err) {
        errorHandler(err);
      }
    };
    const init = async () => {
      fetchContent();
    };

    init();
  };

  // 物件スライダー
  const rf_prop_slider = () => {
    const propSliders = document.querySelectorAll('[data-js-prop-slider]');
    let sliders = {};

    const args = {
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
      },
      pagination: {
        el: ".c-prop-slider__pagination",
        type: "progressbar",
      },
      breakpoints: {
        0: {
          spaceBetween: 16,
          slidesPerView: 1.2,
          slidesOffsetBefore: 32,
          slidesOffsetAfter: 32,
        },
        768: {
          spaceBetween: 24,
          slidesPerView: 4.4,
          slidesOffsetBefore: 40,
          slidesOffsetAfter: 40,
        },
      },
    };

    const setSwiper = () => {
      propSliders.forEach(slider => {
        const propSlider = new Swiper(slider, args);
        sliders[slider.id] = propSlider;
      });
    };

    const init = () => {
      setSwiper();
    };

    init();

  };

  // お部屋リスト


  // 部屋リストリンク
  const rf_room_list_link = () => {
    const links = document.querySelectorAll('[data-js-room-link]');

    links.forEach(link => {
      link.addEventListener('click', e => {
        e.stopPropagation();
        const clicked = e.target;

        if (
          clicked.tagName === 'A' ||
          clicked.tagName === 'BUTTON' ||
          clicked.closest('.swiper-initialized') //動いているswiperは中止対象
        ) {
          console.log('インタラクティブ要素なので中止');
          return
        }

        const target = link.dataset.jsRoomLink;
        window.open(target, '_blank');
      });
    });
  };

  // お部屋リストの制御
  const rf_room_list_toggle = () => {
    const openClass = '--is-open';
    let tempText = '';
    const maxHeightPC = 660;
    const maxHeightSP = 1200;
    const toggles = document.querySelectorAll('[data-js-room-toggle]');


    // トグルボタンのコントロール, 画像の読み込みなどを考慮してwindowロード後
    window.addEventListener('load', () => {
      toggles.forEach(toggle => {
        const target = document.querySelector(toggle.dataset.jsRoomToggle);

        // トグルボタンの表示・非表示をまず決める（デフォルト: 表示）
        if (rf_get_globals('window_state') === 'PC' && target.scrollHeight < maxHeightPC) {
          toggle.classList.add('--is-hide');
        } else if (rf_get_globals('window_state') === 'SP' && target.scrollHeight < maxHeightSP) {
          toggle.classList.add('--is-hide');
        }

        // クリックコントロール
        toggle.addEventListener('click', () => {

          target.classList.toggle(openClass);
          toggle.classList.toggle(openClass);

          // 高さ
          if (target.classList.contains(openClass)) {
            target.style.maxHeight = target.scrollHeight + 'px';
          } else {
            target.style.maxHeight = null;
          }


          // テキスト
          if ('jsRoomToggleText' in toggle.dataset) {
            tempText = toggle.textContent;
            toggle.textContent = toggle.dataset.jsRoomToggleText;
            toggle.dataset.jsRoomToggleText = tempText;
          }
        });
      });
    });

  };

  // 建物・部屋 共通

  const rf_buildroom_main_slide = () => {
    const mv_thumbs_args = {
      spaceBetween: 8,
      freeMode: true,
      watchSlidesProgress: true,
      breakpoints: {
        0: {
          slidesPerView: 4.5,
        },
        768: {
          slidesPerView: 8.5,
        },
      },
    };
    const mv_thumbs = new Swiper('[data-js-buildroom-mv-thumbs]', mv_thumbs_args);

    const mv_args = {
      pagination: {
        el: ".swiper-pagination",
        type: "fraction",
      },
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
      },
      thumbs: {
        swiper: mv_thumbs,
      },
    };
    new Swiper('[data-js-buildroom-mv]', mv_args);
  };

  const rf_modals = () => {
    const modalOpenHtmlClass = '--is-modal-open';
    const modalOpenClass = '--is-open';
    const html = document.documentElement;
    // const modalClass = 'c-modal'
    // const modals = document.querySelectorAll('.' + modalClass)
    const modals = document.querySelectorAll('[data-js-modal-target]');
    const modalOpenBtns = document.querySelectorAll('[data-js-modal]');
    const modalTargetName = 'jsModalTarget';
    // const modalCloseBtns = document.querySelectorAll('[data-js-modal-close]')
    let openedModals = [];

    // 開くボタン
    const setOpenModalBtns = () => {
      modalOpenBtns.forEach(btn => {
        const modalId = btn.dataset.jsModal;
        const targetModal = document.querySelector(modalId);

        btn.addEventListener('click', e => {
          if (btn.tagName === 'A') {
            e.preventDefault();
          }
          targetModal.classList.add(modalOpenClass);
          html.classList.add(modalOpenHtmlClass);
          openedModals.push(modalId);
        });
      });
    };

    // モーダル閉じるアクション
    const closeModal = (modal) => {
      // console.log('モーダル閉じる, openedModalsは?', openedModals)
      console.log(modal.id);
      const index = openedModals.indexOf(modal);
      openedModals.splice(index, 1);
      // console.log('モーダル閉じたあと, openedModalsは?', openedModals)
      modal.classList.remove(modalOpenClass);
      if (openedModals.length === 0) {
        html.classList.remove(modalOpenHtmlClass);
      }
    };

    // モーダル制御
    const setModals = () => {
      modals.forEach(modal => {
        // モーダル本体閉じる
        modal.addEventListener('click', e => {
          if (modalTargetName in e.target.dataset) {
            console.log('モーダルターゲット');
            closeModal(modal);
          }
        });

        // モーダル閉じるボタン
        const modalCloses = modal.querySelectorAll('[data-js-modal-close]');
        modalCloses.forEach(close => {
          close.addEventListener('click', () => {
            closeModal(modal);
          });
        });

      });
    };

    const init = () => {
      setOpenModalBtns();
      setModals();
    };

    init();
  };

  // CTAナビ
  const rf_cta_navi_tel = () => {
    // const nav = document.querySelector('.c-cta-navi-tel');
    const btn = document.querySelector(['[data-js-cta-navi-tel]']);
    const nav = document.querySelector(btn.dataset.jsCtaNaviTel);

    btn.addEventListener('click', () => {
      nav.classList.toggle('--is-open');
    });
  };

  const rf_select_link = () => {

    const selectLinks = document.querySelectorAll('[data-js-select-link]');

    selectLinks.forEach(link => {
      link.addEventListener('change', e => {
        const href = e.target.selectedOptions[0].value;
        location.href = href;
      });
    });
  };

  // 関連物件スライダー
  const rf_related_prop_slider = () => {
    const relatedPropSliders = document.querySelectorAll('[data-js-related-prop-slider]');
    const sliders = [];
    const args = {
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
      },
      pagination: {
        el: ".c-prop-slider__pagination",
        type: "progressbar",
      },
      init: false, //あとで発動
      breakpoints: {
        0: {
          spaceBetween: 16,
          slidesPerView: 1.4,
          slidesOffsetBefore: 32,
          slidesOffsetAfter: 32,
        },
        768: {
          spaceBetween: 24,
          slidesPerView: 3.5,
          slidesOffsetBefore: 40,
          slidesOffsetAfter: 40,
        },
      },
    };

    // Swiper設定
    const setSwiper = () => {
      relatedPropSliders.forEach(slider => {
        const relatedPropSlider = new Swiper(slider, args);
        console.dir(relatedPropSlider);
        sliders.push(relatedPropSlider);
      });
      onLoaded();
    };

    // ロード完了アクション
    const onLoaded = () => {
      sliders.forEach(slider => {
        slider.on('init', () => {
          //ローダーを削除
          const loader = slider.el.querySelector('.c-prop-slider__loader');
          if (loader) {
            loader.remove();
          }
        });
        slider.init();
      });
    };

    const init = () => {
      setSwiper();
    };

    init();
  };

  const rf_ward = () => {
    const dataProp = 'jsWardSelect';
    document.querySelector('#sys-form');
    const btns = Array.from(document.querySelectorAll('[data-js-ward-select]'));
    const checkBoxes = btns.filter(btn => btn.tagName === 'INPUT');
    const boundaries = btns.filter(btn => btn.tagName === 'g');
    let currentWards = [];
    let selectedWards = [];
    const toggleClass = '--is-active';

    // 現在選択中の区
    const getWards = () => {
      return selectedWards
    };

    // １つの区
    // const getWard = ward => {

    // }

    const removeWard = ward => {
      const index = selectedWards.indexOf(ward);
      selectedWards.splice(index, 1);
      console.log('削除後', selectedWards);
    };

    // セット
    const setWard = ward => {
      selectedWards.push(ward);
    };

    // 現在の区
    const getCurrentWards = () => {
      return currentWards
    };
    const setCurrentWards = wards => {
      currentWards = [...wards];
      console.log('前の区', currentWards);
    };


    // チェックボックスのトグル
    const toggleCheckbox = (isAdd, dom) => {
      // 差分チェック
      let differences = null;
      if (isAdd) {
        differences = getWards().filter(element => !(getCurrentWards().includes(element)));
      } else {
        differences = getCurrentWards().filter(element => !(getWards().includes(element)));
      }
      console.log('差分', differences);

      //要素チェック
      const isCheckbox = (dom.tagName === 'INPUT');
      console.log('checkbox?', isCheckbox);

      differences.forEach(diff => {
        console.log('差分', diff);
        const [selectedBoundary] = boundaries.filter(bound => bound.dataset[dataProp] === diff);
        const [selectedCheckbox] = checkBoxes.filter(checkbox => checkbox.dataset[dataProp] === diff);
        console.log('選択された', selectedBoundary, selectedCheckbox);
        selectedBoundary.classList.toggle(toggleClass, isAdd);
        selectedCheckbox.checked = isAdd;
      });
    };

    const setToggleAction = () => {
      btns.forEach(btn => {
        btn.addEventListener('click', () => {
          let isAdd = true; // true or false
          setCurrentWards(getWards()); //現在の区を一旦保存
          const ward = btn.dataset.jsWardSelect;
          if (getWards().includes(ward)) {
            console.log('削除');
            isAdd = false;
            removeWard(ward);
          } else {
            console.log('追加');
            setWard(ward);
          }
          console.log('現在', selectedWards);
          console.log('１個前', currentWards);

          // 地図クリックの場合チェックボックスをトグル
          toggleCheckbox(isAdd, btn);
        });
      });
    };

    // すべてのチェックを外す - 画面戻ったときの対策
    const clearAllCheckboxes = () => {
      btns.forEach(btn => {
        console.dir(btn);
        if (btn.tagName === 'INPUT') {
          console.log(btn.checked);
          console.log(btn.defaultChecked);
          btn.setAttribute('autocomplete', 'off');
          btn.checked = false;
        }
      });
    };

    const init = () => {
      // resetForm()
      clearAllCheckboxes();
      // window.addEventListener('load', () => {
      //   console.log('loaded!')
      // })
      setToggleAction();
    };

    init();
  };

  // 検索結果 - お部屋リストスライダー
  const rf_result_room_slide = () => {
    const room_slides = document.querySelectorAll('[data-js-result-room-slide]');
    const pic_area_selector = '[data-js-result-room-parent]';
    const slide_selector_class = 'swiper';
    const slide_wrapper_class = 'swiper-wrapper';
    const disabled_class = '--is-disabled';
    const flash_msg_class = 'c-result-room__flash-msg';
    // const swipers = null //TODO: swiperのインスタンスを保持
    let click_handlers = {};

    const swiper_arg = {
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
      },
      // spaceBetween: 16,
      // slidesOffsetAfter: 16,
      // slidesOffsetBefore: 16,
    };

    const msgs = {
      no_img: 'これ以上画像はありません',
      fetch_err: 'データ取得エラー',
      // no_data: 'データがありません',
    };


    // フラッシュメッセージ
    const insertFlashMessage = (msg, pic_area) => {
      const msg_html = `<p class="${flash_msg_class}">${msg}</p>`;

      // メッセージを表示中は、追加しない
      if (pic_area.querySelector(`.${flash_msg_class}`)) {
        console.log('NO no no congested right now!!!');
        return
      }

      pic_area.insertAdjacentHTML('beforeend', msg_html);
      const msg_inserted = pic_area.querySelector(`.${flash_msg_class}`);
      console.log(msg_inserted);


      // remove
      msg_inserted.addEventListener('transitionend', () => {
        msg_inserted.remove();
      });

      // タイマー
      setTimeout(() => {
        msg_inserted.classList.add('--is-deactive');
      }, 3000);

    };

    // 取得エラー
    const handleError = (err_msg, pic_area) => {
      let msg = '';
      // フラッシュメッセージ表示
      switch (err_msg) {
        case 'no_img': //画像が１枚以下
          msg = msgs.no_img;
          pic_area.classList.add('--is-no-slide');
          break
        case 'fetch_err':
          msg = msgs.fetch_err;
          break
        default:
          msg = msgs.fetch_err;
      }
      insertFlashMessage(msg, pic_area);
    };

    //古いwrapperを削除し空のwrapperを作成(子要素を全削除するため)
    const removeAllChildren = (target_slide, wrapper) => {
      const new_wrapper = wrapper.cloneNode(false);
      // target_slide.insertAdjacentElement('afterbegin', new_node)
      target_slide.replaceChild(new_wrapper, wrapper);
    };

    // Swiperの設定
    const setSwiper = (data, target_slide) => {
      let html = '';
      data.forEach(item => {
        // <img src="${item.filename}" alt="${item.part}" loading="lazy">
        html += `<div class="c-result-room__slide-item swiper-slide">
      <img src="${item.thumbnailUrl}" alt="${item.id}" loading="lazy" title="テスト用JSONデータ">
      </div>`;
      });

      const wrapper = target_slide.querySelector(`.${slide_wrapper_class}`);

      removeAllChildren(target_slide, wrapper);

      const new_wrapper = target_slide.querySelector(`.${slide_wrapper_class}`);
      new_wrapper.insertAdjacentHTML('beforeend', html);

      // Swiper起動
      // TODO: スライダーインスタンスを保管してコントロール可能にするかもしれない
      const swiper = new Swiper(target_slide, swiper_arg);
      swiper.slideTo(1); //２枚目のスライドへ移動させる
    };

    // スライドデータの取得
    const getSlideData = async (url) => {
      try {
        const response = await fetch(url);

        // データ取得エラー
        if (!response.ok) {
          throw new Error('fetch_err')
        }

        const data = await response.json();
        console.log(data);
        // データ数が１の場合スライドさせない
        if (data.length > 1) {
          return data
        } else {
          throw new Error('no_img')
        }
      } catch (err) {
        console.dir(err);
        return err.message
      }
    };

    // ボタンクリックアクション
    async function setClickAction(args, event) {
      // console.log(this)
      // console.log('渡されたデータ', args, event)
      const [btn] = args;
      const url = btn.dataset.jsResultRoomSlide;
      const pic_area = btn.closest(pic_area_selector);

      // ボタン無効化中は操作しない
      if (btn.classList.contains(disabled_class)) return false

      // ローダー作成 - _loader.js
      const loader = new RF_GLOBALS.RfLoader(pic_area);

      // ボタン無効化
      btn.classList.add(disabled_class);

      try {
        const data = await getSlideData(url);
        console.log(data);
        // JSONデータかどうかを確認
        if (typeof data === 'object' && JSON.parse(JSON.stringify(data))) {
          // データ取得成功
          const target_slide = btn.closest(`.${slide_selector_class}`);
          const id = btn.dataset.jsResultRoomId;
          btn.removeEventListener('click', click_handlers[id]);
          // ハンドラーをオブジェクトから削除（容量節約のため）
          delete click_handlers[id];
          // console.log(click_handlers)
          setSwiper(data, target_slide);
        } else {
          throw new Error(data)
        }
      } catch (err) {
        // なんらかのエラー
        handleError(err.message, pic_area);
      }

      // ボタン有効化
      btn.classList.remove(disabled_class);

      // ローダー削除
      loader.removeLoader();
    }

    const setClickHandler = (btn) => {
      const id = btn.dataset.jsResultRoomId;
      // bindを使用した場合、別関数になるのでremoveEventListenerできない。故にbindしたもの保存して使う
      click_handlers[id] = setClickAction.bind(null, [btn]);
      console.log(click_handlers);
      btn.addEventListener('click', click_handlers[id]);
      btn.click();
      // const clickEvent = new Event('click')
      // btn.dispatchEvent(clickEvent)
    };

    // ボタンクリックイベント設定
    const setSlideAction = () => {
      room_slides.forEach(btn => {
        btn.addEventListener('click', () => {
          setClickHandler(btn);
        }, {
          once: true
        });
      });
    };

    const init = () => {
      setSlideAction();
    };

    init();
  };

  // 検索 - 駅・沿線

  const rf_search_ensen_checkbox = () => {
    const forms = document.querySelectorAll('[data-js-form-checkbox]');
    const form_ensen_step_one_id = 'form-ensen-step1';
    const form_ensen_steps_id = [
      form_ensen_step_one_id,
    ];
    const btn_search_id = 'form-ensen-submit';
    const btn_disabled_class = '--is-disabled';
    let checkboxes = [];

    // 選択・検索ボタンのクラスをトグル
    const toggleBtnClass = (el, status) => {
      const is_disabled = !status;
      el.classList.toggle(btn_disabled_class, is_disabled);
      if (is_disabled) {
        el.setAttribute('disabled', 'disabled');
      } else {
        el.removeAttribute('disabled');
      }
    };

    // チェックボックス操作のコールバック関数
    function checkboxCallback() {
      console.log(this);
      const obj = this;
      const status = obj.checker.getStatus();
      const formId = obj.formId;

      switch (formId) {
        // 沿線の選択の場合 - 選択・検索ボタンのクラスをトグル
        case form_ensen_step_one_id:
          const el = document.querySelector(`#${btn_search_id}`);
          toggleBtnClass(el, status);
      }
    }

    // チェックボックスのステータスチェック
    const checkboxStatus = () => {
      if (checkboxes.length === 0) return
      checkboxes.forEach(obj => {
        const cb = checkboxCallback.bind(obj);
        obj.elements.forEach(checkbox => {
          checkbox.addEventListener('change', cb);
        });
        // １つだけ取り出して、初期チェックを走らせる
        obj.elements[0].dispatchEvent(new Event('change'));
      });
    };

    // チェックボックスの取得
    const getCheckboxes = (forms) => {

      forms.forEach(form => {
        const id = form.id;
        let _checkboxes;

        try {
          if (!id) {
            throw new Error('Please provide form id')
          }
          // そもそもチェックボックスの確認対象のフォームかどうか調べる
          if (!form_ensen_steps_id.includes(id)) {
            throw new Error('This form is not set for checkbox checks')
          }
          // チェックボックス取得 - 対象のものだけ
          _checkboxes = form.querySelectorAll('input[type=checkbox][data-js-checkbox-target]');
          if (_checkboxes.length === 0) {
            throw new Error('Target checkbox does not exist.')
          }
        } catch (err) {
          console.log(err.message);
          return
        }

        checkboxes.push({
          formId: id,
          checker: new RF_GLOBALS.RfCheckboxStatus(form, _checkboxes),
          elements: _checkboxes,
        });

      });

      checkboxStatus();

    };




    const init = () => {
      getCheckboxes(forms);
    };

    init();

  };

  class RfMediaQuery {
    #cb
    #event
    #minWidth = 768
    #query = matchMedia(`(min-width: ${this.#minWidth}px)`);

    constructor(cb, event, minWidth = this.#minWidth) {
      this.#cb = cb;
      this.#event = event;
      this.#minWidth = minWidth;
      this.#query = matchMedia(`(min-width: ${minWidth}px)`);
      this.#attachListener();
    }

    #attachListener() {
      console.log('media query function: ', this.#cb);
      this.#query.addEventListener(this.#event, this.#cb);
      this.#query.dispatchEvent(new Event(this.#event)); //初回限定
    }
  }

  // 検索方法・選び方の変更のtippy展開
  const rf_search_change_method = () => {
    const btn = document.querySelector('[data-js-search-change-method]');
    let tippyInstance;
    const tippyFunc = (ref) => {
      const id = ref.dataset.jsSearchMethod;
      document.querySelector(id);
      return document.querySelector(id)
    };

    const tippySettingCommon = {
      content: tippyFunc,
      animation: 'shift-away',
      interactive: true,
      interactiveBorder: 10,
      trigger: 'click',
      delay: [null, 300],
      arrow: tippy.roundArrow,
      theme: 'rf',
    };
    const tippySettingSP = {
      placement: 'bottom',
    };
    const tippySettingPC = {
      placement: 'right',
    };

    // メディアクエリのブレイクポイントでtippyの設定を変更する
    const change_tippy_setting = event => {
      console.log('media event', event);
      const is_matched = event.matches || event.currentTarget.matches;
      console.log('is_matched: ', is_matched);
      let tippySetting;
      if (is_matched) {
        console.log('tippy PC');
        tippySetting = {
          // ...tippySettingCommon,
          ...tippySettingPC
        };
      } else {
        console.log('tippy SP');
        tippySetting = {
          // ...tippySettingCommon,
          ...tippySettingSP
        };
      }
      tippyInstance.setProps(tippySetting);
    };

    const set_tippy = () => {
      console.log('tippy init');
      let tippySetting;
      if (RF_GLOBALS.RF_CONFIG['window_state'] === 'PC') {
        tippySetting = {
          ...tippySettingCommon,
          ...tippySettingPC
        };
      } else if (RF_GLOBALS.RF_CONFIG['window_state'] === 'SP') {
        tippySetting = {
          ...tippySettingCommon,
          ...tippySettingSP
        };
      }

      console.log('tippy setting: ', tippySetting);
      tippyInstance = tippy(btn, tippySetting);
    };

    const init = () => {
      set_tippy();
      new RF_GLOBALS.RfMediaQuery(change_tippy_setting, 'change');
    };

    init();
  };

  // =======================================================
  // Inits
  const rf_init = () => {

    // Viewport checker (SP or PC)
    rf_responsive_check();

    // グローバル変数、関数、はRF_GLOBALSにまとめ、windowにアサインする
    window['RF_GLOBALS'] = {
      ...window['RF_GLOBALS'],
      RfLoader,
      RfCheckboxStatus,
      RfMediaQuery,
    };

    // rf_set_globals({
    //   window_state: 'PC',
    //   breakpoint: 768,
    // })


    console.log(window['RF_GLOBALS']);


    // Global Navigation
    if (document.querySelector('[data-js-gnav]')) {
      rf_gnav();
    }

    // Toggles
    if (document.querySelector('[data-js-toggle]')) {
      rf_toggles();
    }

    // TOPページ - 本日掲載
    if (document.querySelector('[data-js-today-target]')) {
      rf_todays_count();
    }

    // Topページ - バナー
    if (document.querySelector('[data-js-top-banners]')) {
      rf_top_banners();
    }

    // 物件スライダー(TOPページ)
    if (document.querySelector('[data-js-prop-slider]')) {
      rf_prop_slider();
    }

    // 物件スライダー(関連）
    if (document.querySelector('[data-js-related-prop-slider]')) {
      rf_related_prop_slider();
    }

    // お部屋リストリンク
    if (document.querySelector('[data-js-room-link]')) {
      rf_room_list_link();
      rf_room_list_toggle();
    }

    // 建物・部屋共通
    if (document.querySelector('[data-js-buildroom-mv]')) {
      rf_buildroom_main_slide();
    }
    if (document.querySelector('[data-js-buildroom-mv-thumbs]')) ;

    // モーダル
    if (document.querySelector('[data-js-modal]')) {
      rf_modals();
    }

    // CTAナビ
    if (document.querySelector('[data-js-cta-navi-tel]')) {
      rf_cta_navi_tel();
    }

    // セレクトリンク
    if (document.querySelector('[data-js-select-link]')) {
      rf_select_link();
    }

    // 区の選択
    if (document.querySelector(`[data-js-ward-select]`)) {
      rf_ward();
    }

    // 検索結果 - お部屋リストスライド
    if (document.querySelector('[data-js-result-room-slide]')) {
      rf_result_room_slide();
    }

    // 検索 - 駅・沿線チェックボックス
    if (document.querySelector('[data-js-form-checkbox]')) {
      rf_search_ensen_checkbox();
    }

    // 検索の方法、選び方の変更
    if (document.querySelector('[data-js-search-change-method]')) {
      rf_search_change_method();
    }
  };

  rf_init();

})();
//# sourceMappingURL=rf.min.js.map
