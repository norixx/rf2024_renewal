(function () {
  'use strict';

  var toastify$1 = {exports: {}};

  /*!
   * Toastify js 1.12.0
   * https://github.com/apvarun/toastify-js
   * @license MIT licensed
   *
   * Copyright (C) 2018 Varun A P
   */
  var toastify = toastify$1.exports;

  var hasRequiredToastify;

  function requireToastify () {
  	if (hasRequiredToastify) return toastify$1.exports;
  	hasRequiredToastify = 1;
  	(function (module) {
  		(function(root, factory) {
  		  if (module.exports) {
  		    module.exports = factory();
  		  } else {
  		    root.Toastify = factory();
  		  }
  		})(toastify, function(global) {
  		  // Object initialization
  		  var Toastify = function(options) {
  		      // Returning a new init object
  		      return new Toastify.lib.init(options);
  		    },
  		    // Library version
  		    version = "1.12.0";

  		  // Set the default global options
  		  Toastify.defaults = {
  		    oldestFirst: true,
  		    text: "Toastify is awesome!",
  		    node: undefined,
  		    duration: 3000,
  		    selector: undefined,
  		    callback: function () {
  		    },
  		    destination: undefined,
  		    newWindow: false,
  		    close: false,
  		    gravity: "toastify-top",
  		    positionLeft: false,
  		    position: '',
  		    backgroundColor: '',
  		    avatar: "",
  		    className: "",
  		    stopOnFocus: true,
  		    onClick: function () {
  		    },
  		    offset: {x: 0, y: 0},
  		    escapeMarkup: true,
  		    ariaLive: 'polite',
  		    style: {background: ''}
  		  };

  		  // Defining the prototype of the object
  		  Toastify.lib = Toastify.prototype = {
  		    toastify: version,

  		    constructor: Toastify,

  		    // Initializing the object with required parameters
  		    init: function(options) {
  		      // Verifying and validating the input object
  		      if (!options) {
  		        options = {};
  		      }

  		      // Creating the options object
  		      this.options = {};

  		      this.toastElement = null;

  		      // Validating the options
  		      this.options.text = options.text || Toastify.defaults.text; // Display message
  		      this.options.node = options.node || Toastify.defaults.node;  // Display content as node
  		      this.options.duration = options.duration === 0 ? 0 : options.duration || Toastify.defaults.duration; // Display duration
  		      this.options.selector = options.selector || Toastify.defaults.selector; // Parent selector
  		      this.options.callback = options.callback || Toastify.defaults.callback; // Callback after display
  		      this.options.destination = options.destination || Toastify.defaults.destination; // On-click destination
  		      this.options.newWindow = options.newWindow || Toastify.defaults.newWindow; // Open destination in new window
  		      this.options.close = options.close || Toastify.defaults.close; // Show toast close icon
  		      this.options.gravity = options.gravity === "bottom" ? "toastify-bottom" : Toastify.defaults.gravity; // toast position - top or bottom
  		      this.options.positionLeft = options.positionLeft || Toastify.defaults.positionLeft; // toast position - left or right
  		      this.options.position = options.position || Toastify.defaults.position; // toast position - left or right
  		      this.options.backgroundColor = options.backgroundColor || Toastify.defaults.backgroundColor; // toast background color
  		      this.options.avatar = options.avatar || Toastify.defaults.avatar; // img element src - url or a path
  		      this.options.className = options.className || Toastify.defaults.className; // additional class names for the toast
  		      this.options.stopOnFocus = options.stopOnFocus === undefined ? Toastify.defaults.stopOnFocus : options.stopOnFocus; // stop timeout on focus
  		      this.options.onClick = options.onClick || Toastify.defaults.onClick; // Callback after click
  		      this.options.offset = options.offset || Toastify.defaults.offset; // toast offset
  		      this.options.escapeMarkup = options.escapeMarkup !== undefined ? options.escapeMarkup : Toastify.defaults.escapeMarkup;
  		      this.options.ariaLive = options.ariaLive || Toastify.defaults.ariaLive;
  		      this.options.style = options.style || Toastify.defaults.style;
  		      if(options.backgroundColor) {
  		        this.options.style.background = options.backgroundColor;
  		      }

  		      // Returning the current object for chaining functions
  		      return this;
  		    },

  		    // Building the DOM element
  		    buildToast: function() {
  		      // Validating if the options are defined
  		      if (!this.options) {
  		        throw "Toastify is not initialized";
  		      }

  		      // Creating the DOM object
  		      var divElement = document.createElement("div");
  		      divElement.className = "toastify on " + this.options.className;

  		      // Positioning toast to left or right or center
  		      if (!!this.options.position) {
  		        divElement.className += " toastify-" + this.options.position;
  		      } else {
  		        // To be depreciated in further versions
  		        if (this.options.positionLeft === true) {
  		          divElement.className += " toastify-left";
  		          console.warn('Property `positionLeft` will be depreciated in further versions. Please use `position` instead.');
  		        } else {
  		          // Default position
  		          divElement.className += " toastify-right";
  		        }
  		      }

  		      // Assigning gravity of element
  		      divElement.className += " " + this.options.gravity;

  		      if (this.options.backgroundColor) {
  		        // This is being deprecated in favor of using the style HTML DOM property
  		        console.warn('DEPRECATION NOTICE: "backgroundColor" is being deprecated. Please use the "style.background" property.');
  		      }

  		      // Loop through our style object and apply styles to divElement
  		      for (var property in this.options.style) {
  		        divElement.style[property] = this.options.style[property];
  		      }

  		      // Announce the toast to screen readers
  		      if (this.options.ariaLive) {
  		        divElement.setAttribute('aria-live', this.options.ariaLive);
  		      }

  		      // Adding the toast message/node
  		      if (this.options.node && this.options.node.nodeType === Node.ELEMENT_NODE) {
  		        // If we have a valid node, we insert it
  		        divElement.appendChild(this.options.node);
  		      } else {
  		        if (this.options.escapeMarkup) {
  		          divElement.innerText = this.options.text;
  		        } else {
  		          divElement.innerHTML = this.options.text;
  		        }

  		        if (this.options.avatar !== "") {
  		          var avatarElement = document.createElement("img");
  		          avatarElement.src = this.options.avatar;

  		          avatarElement.className = "toastify-avatar";

  		          if (this.options.position == "left" || this.options.positionLeft === true) {
  		            // Adding close icon on the left of content
  		            divElement.appendChild(avatarElement);
  		          } else {
  		            // Adding close icon on the right of content
  		            divElement.insertAdjacentElement("afterbegin", avatarElement);
  		          }
  		        }
  		      }

  		      // Adding a close icon to the toast
  		      if (this.options.close === true) {
  		        // Create a span for close element
  		        var closeElement = document.createElement("button");
  		        closeElement.type = "button";
  		        closeElement.setAttribute("aria-label", "Close");
  		        closeElement.className = "toast-close";
  		        closeElement.innerHTML = "&#10006;";

  		        // Triggering the removal of toast from DOM on close click
  		        closeElement.addEventListener(
  		          "click",
  		          function(event) {
  		            event.stopPropagation();
  		            this.removeElement(this.toastElement);
  		            window.clearTimeout(this.toastElement.timeOutValue);
  		          }.bind(this)
  		        );

  		        //Calculating screen width
  		        var width = window.innerWidth > 0 ? window.innerWidth : screen.width;

  		        // Adding the close icon to the toast element
  		        // Display on the right if screen width is less than or equal to 360px
  		        if ((this.options.position == "left" || this.options.positionLeft === true) && width > 360) {
  		          // Adding close icon on the left of content
  		          divElement.insertAdjacentElement("afterbegin", closeElement);
  		        } else {
  		          // Adding close icon on the right of content
  		          divElement.appendChild(closeElement);
  		        }
  		      }

  		      // Clear timeout while toast is focused
  		      if (this.options.stopOnFocus && this.options.duration > 0) {
  		        var self = this;
  		        // stop countdown
  		        divElement.addEventListener(
  		          "mouseover",
  		          function(event) {
  		            window.clearTimeout(divElement.timeOutValue);
  		          }
  		        );
  		        // add back the timeout
  		        divElement.addEventListener(
  		          "mouseleave",
  		          function() {
  		            divElement.timeOutValue = window.setTimeout(
  		              function() {
  		                // Remove the toast from DOM
  		                self.removeElement(divElement);
  		              },
  		              self.options.duration
  		            );
  		          }
  		        );
  		      }

  		      // Adding an on-click destination path
  		      if (typeof this.options.destination !== "undefined") {
  		        divElement.addEventListener(
  		          "click",
  		          function(event) {
  		            event.stopPropagation();
  		            if (this.options.newWindow === true) {
  		              window.open(this.options.destination, "_blank");
  		            } else {
  		              window.location = this.options.destination;
  		            }
  		          }.bind(this)
  		        );
  		      }

  		      if (typeof this.options.onClick === "function" && typeof this.options.destination === "undefined") {
  		        divElement.addEventListener(
  		          "click",
  		          function(event) {
  		            event.stopPropagation();
  		            this.options.onClick();
  		          }.bind(this)
  		        );
  		      }

  		      // Adding offset
  		      if(typeof this.options.offset === "object") {

  		        var x = getAxisOffsetAValue("x", this.options);
  		        var y = getAxisOffsetAValue("y", this.options);

  		        var xOffset = this.options.position == "left" ? x : "-" + x;
  		        var yOffset = this.options.gravity == "toastify-top" ? y : "-" + y;

  		        divElement.style.transform = "translate(" + xOffset + "," + yOffset + ")";

  		      }

  		      // Returning the generated element
  		      return divElement;
  		    },

  		    // Displaying the toast
  		    showToast: function() {
  		      // Creating the DOM object for the toast
  		      this.toastElement = this.buildToast();

  		      // Getting the root element to with the toast needs to be added
  		      var rootElement;
  		      if (typeof this.options.selector === "string") {
  		        rootElement = document.getElementById(this.options.selector);
  		      } else if (this.options.selector instanceof HTMLElement || (typeof ShadowRoot !== 'undefined' && this.options.selector instanceof ShadowRoot)) {
  		        rootElement = this.options.selector;
  		      } else {
  		        rootElement = document.body;
  		      }

  		      // Validating if root element is present in DOM
  		      if (!rootElement) {
  		        throw "Root element is not defined";
  		      }

  		      // Adding the DOM element
  		      var elementToInsert = Toastify.defaults.oldestFirst ? rootElement.firstChild : rootElement.lastChild;
  		      rootElement.insertBefore(this.toastElement, elementToInsert);

  		      // Repositioning the toasts in case multiple toasts are present
  		      Toastify.reposition();

  		      if (this.options.duration > 0) {
  		        this.toastElement.timeOutValue = window.setTimeout(
  		          function() {
  		            // Remove the toast from DOM
  		            this.removeElement(this.toastElement);
  		          }.bind(this),
  		          this.options.duration
  		        ); // Binding `this` for function invocation
  		      }

  		      // Supporting function chaining
  		      return this;
  		    },

  		    hideToast: function() {
  		      if (this.toastElement.timeOutValue) {
  		        clearTimeout(this.toastElement.timeOutValue);
  		      }
  		      this.removeElement(this.toastElement);
  		    },

  		    // Removing the element from the DOM
  		    removeElement: function(toastElement) {
  		      // Hiding the element
  		      // toastElement.classList.remove("on");
  		      toastElement.className = toastElement.className.replace(" on", "");

  		      // Removing the element from DOM after transition end
  		      window.setTimeout(
  		        function() {
  		          // remove options node if any
  		          if (this.options.node && this.options.node.parentNode) {
  		            this.options.node.parentNode.removeChild(this.options.node);
  		          }

  		          // Remove the element from the DOM, only when the parent node was not removed before.
  		          if (toastElement.parentNode) {
  		            toastElement.parentNode.removeChild(toastElement);
  		          }

  		          // Calling the callback function
  		          this.options.callback.call(toastElement);

  		          // Repositioning the toasts again
  		          Toastify.reposition();
  		        }.bind(this),
  		        400
  		      ); // Binding `this` for function invocation
  		    },
  		  };

  		  // Positioning the toasts on the DOM
  		  Toastify.reposition = function() {

  		    // Top margins with gravity
  		    var topLeftOffsetSize = {
  		      top: 15,
  		      bottom: 15,
  		    };
  		    var topRightOffsetSize = {
  		      top: 15,
  		      bottom: 15,
  		    };
  		    var offsetSize = {
  		      top: 15,
  		      bottom: 15,
  		    };

  		    // Get all toast messages on the DOM
  		    var allToasts = document.getElementsByClassName("toastify");

  		    var classUsed;

  		    // Modifying the position of each toast element
  		    for (var i = 0; i < allToasts.length; i++) {
  		      // Getting the applied gravity
  		      if (containsClass(allToasts[i], "toastify-top") === true) {
  		        classUsed = "toastify-top";
  		      } else {
  		        classUsed = "toastify-bottom";
  		      }

  		      var height = allToasts[i].offsetHeight;
  		      classUsed = classUsed.substr(9, classUsed.length-1);
  		      // Spacing between toasts
  		      var offset = 15;

  		      var width = window.innerWidth > 0 ? window.innerWidth : screen.width;

  		      // Show toast in center if screen with less than or equal to 360px
  		      if (width <= 360) {
  		        // Setting the position
  		        allToasts[i].style[classUsed] = offsetSize[classUsed] + "px";

  		        offsetSize[classUsed] += height + offset;
  		      } else {
  		        if (containsClass(allToasts[i], "toastify-left") === true) {
  		          // Setting the position
  		          allToasts[i].style[classUsed] = topLeftOffsetSize[classUsed] + "px";

  		          topLeftOffsetSize[classUsed] += height + offset;
  		        } else {
  		          // Setting the position
  		          allToasts[i].style[classUsed] = topRightOffsetSize[classUsed] + "px";

  		          topRightOffsetSize[classUsed] += height + offset;
  		        }
  		      }
  		    }

  		    // Supporting function chaining
  		    return this;
  		  };

  		  // Helper function to get offset.
  		  function getAxisOffsetAValue(axis, options) {

  		    if(options.offset[axis]) {
  		      if(isNaN(options.offset[axis])) {
  		        return options.offset[axis];
  		      }
  		      else {
  		        return options.offset[axis] + 'px';
  		      }
  		    }

  		    return '0px';

  		  }

  		  function containsClass(elem, yourClass) {
  		    if (!elem || typeof yourClass !== "string") {
  		      return false;
  		    } else if (
  		      elem.className &&
  		      elem.className
  		        .trim()
  		        .split(/\s+/gi)
  		        .indexOf(yourClass) > -1
  		    ) {
  		      return true;
  		    } else {
  		      return false;
  		    }
  		  }

  		  // Setting up the prototype for the init object
  		  Toastify.lib.init.prototype = Toastify.lib;

  		  // Returning the Toastify function to be assigned to the window object/module
  		  return Toastify;
  		}); 
  	} (toastify$1));
  	return toastify$1.exports;
  }

  requireToastify();

  /**
   * グローバル変数、グローバル設定
   */
  window.RF_GLOBALS = {};
  window.RF_GLOBALS.RF_CONFIG = {
    window_state: 'PC',
    breakpoint: 768,
  };

  const rf_set_globals = settings => {
    window.RF_GLOBALS.RF_CONFIG = {
      ...window.RF_GLOBALS.RF_CONFIG,
      ...settings,
    };
  };

  const rf_get_globals = key => {
    return RF_GLOBALS['RF_CONFIG'][key]
  };

  const rf_responsive_check = () => {
    window.addEventListener('resize', () => {
      requestAnimationFrame(() => {
        let current_state = rf_get_globals('window_state');

        if (window.innerWidth < rf_get_globals('breakpoint') && current_state === 'PC') {
          rf_set_globals({
            window_state: 'SP',
          });
          console.log('set to SP');
        } else if (window.innerWidth >= rf_get_globals('breakpoint') && current_state === 'SP') {
          rf_set_globals({
            window_state: 'PC',
          });
          console.log('set to PC');
        }
      });

    });

    // 初動
    window.dispatchEvent(new Event('resize'));
  };

  // ローダー
  /**
   * ローダー
   * @param {string} target - ローダーを挿入するターゲット（指定がなければbody）
   * @param {string} msg - ローダーのメッセージ（キャプション） default: 'Loading...' //未使用
   * @param {string} size - ローダーのサイズ（スタイルシートを参照） default: 'md'
   * @param {string} style - ローダーのスタイル（スタイルシートを参照） default: '--bg-black'
   */
  class RfLoader {
    #settings = {
      target: document.body,
      msg: 'Loading...', //TODO: 未使用
      size: 'md',
      style: '--bg-black',
      loaderClass: 'c-loader',
      loader: null,
    }
    constructor(settings = null) {
      this.#settings = {...this.#settings, ...settings};
      console.log(this.#settings);
      this.#init();
    }

    // ローダーを挿入（コンストラクタから呼び出し）
    #insertLoader(loader) {
      console.log('ローダーを挿入');

      if(typeof loader === 'string') {
        this.#settings.target.insertAdjacentHTML('beforeend', loader);
      } else if(typeof loader === 'object') {
        // 2回目以降はこっち
        this.#settings.target.insertAdjacentElement('beforeend', loader);
      }
      if(!this.#settings.loader) {
        this.#settings.loader = this.#settings.target.querySelector('.' + this.#settings.loaderClass); //ローダー要素を保管
      }
    }

    // ローダーを削除（public）
    removeLoader() {
      console.log('ローダーを削除');
      this.#settings.loader.remove();
    }

    // ローダーを再挿入（public）
    reinsertLoader() {
      console.log('ローダーを再挿入');
      this.#insertLoader(this.#settings.loader);
    }

    // ローダーを作成
    #makeLoader() {
      console.log('ローダーを作成');
      let size = '';
      if (this.#settings.size !== 'md') size = `--${this.#settings.size}`;
      const loader = `<div class="${this.#settings.loaderClass} ${this.#settings.style} ${size}"></div>`;
      this.#insertLoader(loader);
    }

    #init() {
      this.#makeLoader();
    }
  }

  /**
   * Checkbox Status - チェックボックスのステータスを確認する
   * constructor
   * @param {HTMLFormElement} form
   * @param {HTMLInputElement[]} checkboxes
   */
  class RfCheckboxStatus {
    #form;
    #checkboxes;
    #validator = {
      get(target, key) {
        console.log("target&key: ", target, key);
        const status = Array.prototype.slice
          .call(target["elements"])
          .some((x) => x.checked);
        console.log(target["elements"]);
        console.log(status);
        target[key] = status;
        return target[key];
      }
    };
    #checkBoxObj = {
      status: null,
      elements: null
    };
    #store;

    constructor(form, checkboxes) {
      if (!form || !checkboxes) throw new Error("No Form selected!");
      console.log("yes checkboxes!");
      this.#form = form;
      this.#checkboxes = checkboxes;
      this.#checkBoxObj["elements"] = this.#checkboxes;
      this.#store = new Proxy(this.#checkBoxObj, this.#validator);
      // this.#cb = cb
    }


    getStatus() {
      return this.#store.status;
    }
  }

  class RfModals {
    #modalOpenHtmlClass = '--is-modal-open'
    #modalOpenClass = '--is-open'
    #html = document.documentElement
    #modals
    #modalOpenBtns
    #modalAjaxOpenBtns
    #modalTargetName = 'jsModalTarget'
    #openedModals = []
    #events = {}

    /**
     * Initializes a new instance of the RfModals class.
     *
     * @param {Object|null} modals - Optional array of modal elements to be added dynamically.
     * @example {modal: data-js-modal-target(モーダル本体), modalOpenBtn: data-js-modal(モーダル開くボタン)}
     * @return {void}
     */
    constructor(modals = null) {
      // このオブジェクトが初期化されていない場合に、ダイナミックに追加されるモーダル要素を追加するのであれば追加。
      if(modals) {
        this.modal(modals);
        return
      }

      this.#modals = Array.from(document.querySelectorAll('[data-js-modal-target]'));
      this.#modalOpenBtns = Array.from(document.querySelectorAll('[data-js-modal]'));
      this.#modalAjaxOpenBtns = Array.from(document.querySelectorAll('[data-js-ajax-modal]'));

      this.#setModalOpenBtns();
      this.#setModals();
    }

    // ===

    // イベント登録
    on(eventName, callback) {
      if(!this.#events[eventName]) {
        this.#events[eventName] = [];
      }
      this.#events[eventName].push(callback);
    }

    // イベント発動
    // dataは発動させる時に渡すデータ。最終的にコールバック関数で受け取るためのもので、イベント発動の際に渡すデータ。データはイベントごとに自由に設定する
    async #emit(eventName, data = null) {
      if(this.#events[eventName]) {
        const promises = this.#events[eventName].map(callback => {
          return Promise.resolve(callback(data))
        });

        return Promise.all(promises)
      }
    }


    // ===

    // モーダルを開く
    openModal(modalId) {
      const targetModal = document.querySelector(modalId);
      console.dir(targetModal);

      targetModal.classList.add(this.#modalOpenClass); //モーダルターゲット(本体)にopenクラスを追加
      this.#html.classList.add(this.#modalOpenHtmlClass); //htmlタグにopenクラスを追加
      this.#openedModals.push(modalId); //モーダル開くリストに追加
      console.log('opened modals', this.#openedModals);
    }

    // 開くボタンにクリックイベントを設定
    #setModalOpenBtnEvent(btns) {
      // check if btns is element or nodelist
      const btnSet = btns instanceof Element ? [btns] : Array.from(btns);
      btnSet.forEach(btn => {
        const modalId = btn.dataset.jsModal;
        btn.addEventListener('click', e => {
          if (btn.tagName === 'A' || btn.tagName === 'BUTTON') {
            e.preventDefault();
          }

          this.openModal(modalId);
        });
      });
    }

    // 開くボタンの設定
    #setModalOpenBtns() {
      this.#modalOpenBtns.forEach(btn => {
        this.#setModalOpenBtnEvent(btn);
      });
    }

    // ===

    /**
     * モーダルを閉じる
     * 
     * @param object modal モーダル要素オブジェクト
     */
    async closeModal(modal) {
      // beforeCloseイベント発動
      // modalはモーダル要素オブジェクト
      await this.#emit('beforeClose', modal);

      // console.log('モーダル閉じる, openedModalsは?', openedModals)
      // console.log(modal.id)
      // console.log(modal instanceof Element)
      const index = this.#openedModals.indexOf(modal);
      this.#openedModals.splice(index, 1);
      // console.log('モーダル閉じたあと, openedModalsは?', openedModals)
      console.log('閉じる対象のモーダル: ', modal);
      modal.classList.remove(this.#modalOpenClass);

      // モーダルが多重に開いている場合、すべてのモーダルが閉じていることをチェックしてHTMLからもクラスを削除する
      if (this.#openedModals.length === 0) {
        this.#html.classList.remove(this.#modalOpenHtmlClass);
      }

      console.log('closing...opened modals', this.#openedModals);
    }

    // ===

    // モーダルを閉じるイベント設定
    #setModalCloseEvent(modal) {
      // モーダル本体クリックで閉じる
      // (モーダルの何もないところをクリックしたとき閉じる)
      modal.addEventListener('click', e => {
        console.log('モーダル本体クリック',this.#modalTargetName, e.target.dataset);
        if (this.#modalTargetName in e.target.dataset) {
          console.log('モーダルターゲット(本体)クリックで閉じる', modal);
          this.closeModal(modal);
        }
      });

      // モーダル閉じるボタンの設定
      // (モーダル本体からモーダル閉じるボタンを探して設定する)
      const modalCloses = modal.querySelectorAll('[data-js-modal-close]');
      modalCloses.forEach(close => {
        close.addEventListener('click', () => {
          console.log('モーダル閉じるボタンクリック', modal);
          this.closeModal(modal);
        });
      });
    }

    // モーダル設定(コンストラクタからのみ呼び出し)
    #setModals() {
      this.#modals.forEach(modal => {
        this.#setModalCloseEvent(modal);
      });
    }

    // ====================================
    //インスタンス化している場合のメソッド
    
    // モーダル開くボタンのイベント設定
    setModalOpenBtn(modalBtn) {
      this.#setModalOpenBtnEvent(modalBtn);
    }

    // モーダル本体のイベント設定
    setModal(modal){
      this.#setModalCloseEvent(modal);
    }

    // モーダル開くボタンとモーダル本体の設定
    modal(modalObj) {
      if('modalOpenBtn' in modalObj) {
        console.log('モーダル開くボタンセット');
        this.setModalOpenBtn(modalObj.modalOpenBtn);
      }
      if('modal' in modalObj) {
        console.log('モーダルセット');
        this.setModal(modalObj.modal);
      }
    }

  }

  // 部屋一覧のサムネイルをクリックしたときにモーダルを開く
  // 対象: 検索結果 > 建物一覧、部屋一覧ページなど

  const rf_modal_madori = () => {
    let modal = null; //モーダル本体（初回クリック時に作成）
    let modalMadoriContainer = null; //間取り画像をいれる場所
    const madori_images = document.querySelectorAll('[data-js-madori-modal]');
    const modal_id = 'madori-modal';
    const modal_container_id = 'madori-container';

    // モーダルインスタンスが存在するかどうかをチェックし、なければインスタンス化する 
    if(!RF_GLOBALS.hasOwnProperty('rf_modals')) {
      console.log('rf_modals not exists');
      RF_GLOBALS.rf_modals = new RF_GLOBALS.RfModals();
    } else {
      console.log('rf_modalsはすでに存在しています');
    }


    // モーダル要素作成とモーダル本体の設定
    const createModal = () => {
      const modalHtml = `
      <div class="c-buildroom-modal --madori-modal c-modal" id="${modal_id}" data-js-modal-target>
        <button type="button" data-js-buildroom-modal-close data-js-modal-close class="c-buildroom-modal__close"><span class="u-visually-hidden">閉じる</span></button>
        <div class="c-buildroom-modal__container" id="${modal_container_id}"></div>
      </div>
    `;
      document.body.insertAdjacentHTML('beforeend', modalHtml);

      // モーダル設定（閉じる制御を追加）
      modal = document.querySelector('#' + modal_id);
      modalMadoriContainer = modal.querySelector('#' + modal_container_id);
      // 閉じる際にモーダルの中身を空にする
      RF_GLOBALS.rf_modals.on('beforeClose', modal => {
        if(modal.id !== modal_id) return
        console.log('間取りモーダル閉じるイベント');
        modal.querySelector('#'+ modal_container_id).innerHTML = '';
      });
      RF_GLOBALS.rf_modals.modal({
        modal,
      });
    };

    // TODO: 間取り画像の取得・挿入・エラーハンドリング
    const loadMadoriImage = (imgUrl) => {
      return new Promise((resolve, reject) => {
        const image = new Image();
        
        image.onload = () => {
          resolve(image);
        };
        
        image.onerror = () => {
          console.log('間取り画像の読み込みに失敗しました');
          // Try loading fallback image
          image.src = '/assets/img/common/nophoto.webp';
          resolve(image); // Resolve with fallback image
        };
    
        // 画像をセット
        image.src = imgUrl;
      })
    };

    // クリックイベント(モーダル作成、間取り画像をモーダルに挿入、モーダル開く)設置
    if(madori_images.length > 0) {
      // const eventTracker = new EventListenerTracker()
      madori_images.forEach((image) => {
        image.addEventListener('click', async () => {
          // e.preventDefault()
          // const modalId = image.dataset.jsMadoriModal

          // モーダルが有無をチェックして、無ければ作成
          if(!document.querySelector('.c-buildroom-modal.--madori-modal')) {
            console.log('間取りモーダルが無いので作成します');
            createModal();
          }
          // 間取り画像をコピーしてモーダルに挿入
          // const imgClone = image.cloneNode(true)
          // modalMadoriContainer.insertAdjacentElement('beforeend', imgClone)

          // 念の為、開く前にコンテナを空にする
          modalMadoriContainer.innerHTML = '';

          // モーダルを開く(先に開いてからローダーや画像挿入を行う)
          RF_GLOBALS.rf_modals.openModal('#' + modal_id);
          

          // ローダー
          const loader = new RF_GLOBALS.RfLoader({
            target: document.querySelector('#' + modal_container_id),
            size: 'sm'
          });

          // 間取り画像を取得して挿入
          const imgSrc = image.dataset.jsMadoriPhoto;
          if(imgSrc) {
            try {
              const loadedImage = await loadMadoriImage(imgSrc);
              loader.removeLoader();
              modalMadoriContainer.innerHTML = ''; //連続でモーダル開閉すると画像が重複する場合ので空にする
              modalMadoriContainer.appendChild(loadedImage);
            } catch (error) {
              console.error('画像の読み込みエラー:', error);
              modalMadoriContainer.innerHTML = ''; //連続でモーダル開閉すると画像が重複する場合ので空にする
              loader.removeLoader();
            }
          }

        });
      });
    }

  };

  // 便利な使い方モーダル
  // Cookieをセットして1回のみ自動的に表示する
  // Cookieの保存期間は30日間
  const rf_modal_usage = () => {
    const RF_COOKIE_USAGE = 'rf_modal_usage';

    // Cookieの有無を確認
    const checkCookie = () => {
      return document.cookie.split(';').some(item => item.trim().startsWith(`${RF_COOKIE_USAGE}=`))
    };

    const isCookieExist = checkCookie();
    console.log(isCookieExist);
    if (isCookieExist) {
      return;
    }

    // Set cookie with 30 days expiration
    const setModalCookie = () => {
      const expirationDate = new Date();
      expirationDate.setDate(expirationDate.getDate() + 30);
      
      // Set secure cookie with proper attributes
      document.cookie = `${RF_COOKIE_USAGE}=true; expires=${expirationDate.toUTCString()}; path=/; sameSite=strict;`;
      console.log(document.cookie);
    };

    setModalCookie();

    const openModal = () => {
      const targetModal = document.querySelector('#modal-convenient-usage');

      targetModal.classList.add('--is-open');
    };

    const init = () => {
      openModal();
    };

    init();

  };

  const rf_gnav = () => {
    let _isOpen = false; //グローバルナビゲーションの開閉状態
    let _isOpenSub = false; // PC用 - のLv2のナビゲーションの開閉状態
    let _current = null; // 現在開いているLv1のID
    let _currentSub = null; // PC用 - 現在開いているLv2のID
    const gnavID = 'gnav-main';
    const openClass = '--is-open';
    const lv1Flag = 'jsGnavLv1'; // Lv1のナビゲーションのフラグ(dataset名)
    // const gnavBtnPC = document.querySelectorAll('[data-js-gnav-pc]')
    const gnav = document.querySelector(`#${gnavID}`); //グローバルナビゲーション本体
    const gnavBtn = document.querySelector('#gnav-btn-open');
    const gnavBtnClose = document.querySelector('[data-js-gnav-close]');
    const gnavSubContainer = document.querySelector('#gnav-sub-container');
    const gnavBtnSubContClose = document.querySelector('[data-js-gnav-sub-container-close]');
    const gnavToggles = document.querySelectorAll('[data-js-gnav-sub]');
    const gnavToggleTargets = Array.from(gnavToggles).map(toggle => document.querySelector(toggle.dataset.jsGnavSub));
    const gnavClose = document.querySelectorAll(['[data-js-gnav-sub-close]']);

    // Gnavを閉じる + すべてを閉じる
    const _hideGnav = () => {
      _isOpen = false;
      gnav.classList.remove(openClass);

      // PC サブコンテナを閉じる
      _isOpenSub = false;
      _current = null;
      _currentSub = null;
      gnavSubContainer.classList.remove(openClass);


      // openClassを全て削除
      gnavToggles.forEach(target => {
        target.classList.remove(openClass);
      });
      gnavToggleTargets.forEach(target => {
        target.classList.remove(openClass);
      });

    };

    // Gnavを開く
    const _showGnav = () => {
      _isOpen = true;
      gnav.classList.add(openClass);
    };

    // SP - Gnav(自体)をタップしたら閉じる
    gnav.addEventListener('click', e => {
      const target = e.target;
      // console.log(target.id)
      if (target.id !== gnavID) return
      _hideGnav();
    });

    // SP - Gnavを閉じるボタン
    gnavBtnClose.addEventListener('click', e => {
      _hideGnav();
    });

    // SP - Gnav🍔
    gnavBtn.addEventListener('click', e => {
      if (_isOpen && gnav.classList.contains(openClass)) {
        _hideGnav();
      } else {
        _showGnav();
      }
    });

    // Gnav Toggles
    gnavToggles.forEach(toggle => {
      toggle.addEventListener('click', e => {
        console.log('クリック前のLv2: ', _currentSub);
        const targetID = toggle.dataset.jsGnavSub;

        // PC - Lv1部分をクリックした場合
        if (lv1Flag in toggle.dataset && rf_get_globals('window_state') === 'PC') {
          console.log('PC Lv1 クリック: ', targetID);

          // ▼ サブコンテナ制御
          // 1. 開いている + 同じ => 閉じる
          if (_isOpenSub && _currentSub === targetID) {
            console.log('PC サブコンテナ閉じる');
            _hideGnav();

            return //処理は中止
          }
          // 2. 開いている + 違う => 切り替える（開く）
          if (_isOpenSub && _currentSub !== targetID) {
            console.log('PC サブコンテナ切り替え');

            // 1つ前のサブコンテナ
            document.querySelector(_currentSub).classList.remove(openClass);
          }

          // 3. 開いていない => 開く
          if (_isOpenSub === false) {
            _showGnav(); // Gnavを開く(SP用だけど一応実行)
            gnavSubContainer.classList.add(openClass); //サブコンテナを開く
            _isOpenSub = true;
          }
        }

        _currentSub = targetID;

        console.log('クリック後のLv2: ', _currentSub);
        console.log(_isOpenSub);

        // SP - Lv1部分をクリックした場合でも一応サブコンテナを開く
        if (
          lv1Flag in toggle.dataset &&
          _isOpenSub !== true &&
          rf_get_globals('window_state') === 'SP'
        ) {
          gnavSubContainer.classList.add(openClass); //サブコンテナを開く
          _isOpenSub = true;
        }

        // PC & SP - ターゲットのopenClassをトグル
        document.querySelector(targetID).classList.add(openClass);

        // PC & SP - Lv1を更新
        if (lv1Flag in toggle.dataset) {
          // 1つ前のLv1リンクからopenClassを削除し、新しいものへ追加
          const _prev = document.querySelector(`[data-js-gnav-lv1=${_current}]`);
          console.log('1つ前のLv1', _prev);
          if (_prev) {
            _prev.classList.remove(openClass);
          }

          _current = toggle.dataset[lv1Flag];
          console.log('保存したLv1', _current);
          toggle.classList.add(openClass);
        }
      });
    });

    // PC - サブコンテナを閉じる
    gnavBtnSubContClose.addEventListener('click', () => {
      _hideGnav();
    });

    // SP - サブナビゲーションを閉じる
    gnavClose.forEach(close => {
      close.addEventListener('click', () => {
        const target = document.querySelector(close.dataset.jsGnavSubClose);
        if (target.classList.contains(openClass)) target.classList.remove(openClass);
      });
    });


  };

  // Toggle 共通

  // TODO: AJAXロードされるtoggleもあるので対策する
  const rf_toggles = () => {
    const toggles = document.querySelectorAll('[data-js-toggle]');
    const toggleSelector = 'data-js-toggle';
    const toggleTextSelector = 'data-js-toggle-text';
    const html = document.documentElement;
    const toggleSPClass = 'toggle-sp-only';
    const togglePCClass = 'toggle-pc-only';
    const toggleClass = '--is-open';
    // let mutationControl
    // const mutationConfig = {
    //   childList: true, //対象ノードの子ノードに対する追加・削除の監視を有効に
    //   subtree: true, //対象ノードとその子孫ノードに対する変更の監視を有効に
    //   // attributes: true, //対象ノードの属性に対する変更の監視を有効に
    //   // characterData: true, //対象ノードのテキストデータの変更の監視を有効に
    // };

    // テキスト変更のあるトグルの設定
    const setToggleTextAndClass = toggle => {
      const toggleTarget = document.querySelector(toggle.dataset.jsToggle);

      //トグルボタンに--is-openがついていればターゲットにも追加
      if (toggle.classList.contains(toggleClass) && !toggleTarget.classList.contains(toggleClass)) {
        toggleTarget.classList.add(toggleClass);
        toggle.setAttribute(toggleTextSelector, toggle.textContent);
        toggle.textContent = toggle_text;
      }

      // テキスト変更がある場合
      if (!toggle.hasAttribute(toggleTextSelector)) return
      let toggle_text;
      toggle_text = toggle.dataset.jsToggleText;
    };

    // ミューテーションオブザーバー
    // const setToggleText = () => {
    //   window.addEventListener('load', () => {
    //     mutationControl = new MutationObserver(mutations => {
    //       mutations.forEach(mutation => {
    //         mutation.addedNodes.forEach(node => {
    //           // 要素はnodeType = 1 https://mzl.la/3yeUhju
    //           if (node.nodeType !== Node.ELEMENT_NODE) return
    //           let toggles = []
    //           if (node.hasAttribute(toggleSelector)) {
    //             toggles.push(node)
    //           }
    //           if (node.querySelector(toggleSelector)) {
    //             toggles.push(Array.from(node.querySelectorAll(toggleSelector)))
    //           }

    //           if (!toggles) return

    //           console.log(toggles)

    //           toggles.forEach(toggle => {
    //             if (!toggle.hasAttribute(toggleTextSelector)) return
    //             setToggleTextAndClass(toggle)
    //           })

    //         })
    //       })
    //     })

    //     mutationControl.observe(document.documentElement, mutationConfig)
    //   })
    // }

    // トグルボタンとターゲットのクラス、属性の変更
    const toggleAttrAndText = toggle => {
      //ターゲットの取得
      const toggleTarget = document.querySelector(toggle.dataset.jsToggle);

      // トグルとターゲットのクラス,ARIA属性の切り替え
      toggle.classList.toggle(toggleClass);
      toggle.setAttribute('aria-expanded', toggle.classList.contains(toggleClass));
      if (toggleTarget) {
        toggleTarget.classList.toggle(toggleClass);
        toggleTarget.setAttribute('aria-hidden', !toggle.classList.contains(toggleClass));
      }

      // トグルボタンのテキスト切り替えあれば変更）
      if (!toggle.hasAttribute(toggleTextSelector)) return
      let toggle_text = toggle.getAttribute(toggleTextSelector);
      toggle.setAttribute(toggleTextSelector, toggle.textContent);
      toggle.textContent = toggle_text;
    };

    // トグルボタンの初期化
    const initToggleControl = () => {
      // AJAX追加されるボタンもあるので、ボタン直接ではなくHTMLクリックに変更
      html.addEventListener('click', e => {
        const target = e.target;
        console.dir(target);
        console.log('target: ', target.closest(`[${toggleSelector}]`));
        let toggle;
        if (target.hasAttribute(toggleSelector)) {
          toggle = target;
        } else if (target.closest(`[${toggleSelector}]`)) {
          toggle = target.closest(`[${toggleSelector}]`);
        } else {
          return
        }
        console.log('toggle: ', toggle);

        // テキスト変更 - 分離済み

        // レスポンシブチェック - SPかPCでトグルを制御
        // SP
        if (toggle.classList.contains(toggleSPClass) && rf_get_globals('window_state') !== 'SP') {
          return
        }
        // PC
        if (toggle.classList.contains(togglePCClass) && rf_get_globals('window_state') !== 'PC') {
          return
        }

        // クラス、属性、テキストの変更
        toggleAttrAndText(toggle);

      });

      // toggles.forEach(toggle => {
      //   const target = document.querySelector(toggle.dataset.jsToggle)
      //   let toggle_text
      //   // テキスト変更がある場合
      //   if (toggle.hasAttribute('data-js-toggle-text')) {
      //     toggle_text = toggle.dataset.jsToggleText
      //   }

      //   // 初動 - トグルボタンに--is-openがついていればターゲットにも追加
      //   if (toggle.classList.contains(toggleClass) && !target.classList.contains(toggleClass)) {
      //     target.classList.add(toggleClass)
      //     toggle.setAttribute('data-js-toggle-text', toggle.textContent)
      //     toggle.textContent = toggle_text
      //   }


      //   // レスポンシブチェック
      //   toggle.addEventListener('click', e => {
      //     // const self = e.target
      //     // SP
      //     if (toggle.classList.contains(toggleSPClass) && rf_get_globals('window_state') !== 'SP') {
      //       return
      //     }
      //     // PC
      //     if (toggle.classList.contains(togglePCClass) && rf_get_globals('window_state') !== 'PC') {
      //       return
      //     }

      //     // トグルボタンのテキスト切り替え、クラス切り替え
      //     if (toggle.hasAttribute('data-js-toggle-text')) {
      //       toggle_text = toggle.getAttribute('data-js-toggle-text')
      //       console.log(toggle_text)
      //       toggle.setAttribute('data-js-toggle-text', toggle.textContent)
      //       toggle.textContent = toggle_text
      //     }
      //     toggle.classList.toggle(toggleClass)
      //     toggle.setAttribute('aria-expanded', toggle.classList.contains(toggleClass))

      //     // ターゲットのクラス,ARIA属性の切り替え
      //     target.classList.toggle(toggleClass)
      //     target.setAttribute('aria-hidden', !toggle.classList.contains(toggleClass))
      //   })
      // })
    };

    const init = () => {
      initToggleControl();
      // テキスト変更
      toggles.forEach(toggle => {
        setToggleTextAndClass(toggle);
      });

      //ミューテーションオブザーバー - AJAXで追加されるコンテンツ対策
      // setToggleText()
    };

    init();

  };

  // TOPバナースライダー
  const rf_top_banners = () => {
    const args = {
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
      },
      breakpoints: {
        0: {
          slidesPerView: 1.3,
          spaceBetween: 16,
          slidesOffsetAfter: 16,
          slidesOffsetBefore: 16,
        },
        768: {
          slidesPerView: 4.3,
          spaceBetween: 24,
          slidesOffsetAfter: 24,
          slidesOffsetBefore: 24,
        },
      },
    };

    const setSwiper = () => {
      new Swiper('[data-js-top-banners]', args);
    };

    const init = () => {
      setSwiper();
    };

    init();

  };

  const rf_todays_count = () => {
    // TODO: 英語版対応
    const fetchURL = '/rf/today/';
    const target = document.querySelector('[data-js-today-target]');
    // const elementClass = '.c-top-search__prop-status-list'
    const dataID = '#todays-data';
    const targetElements = target.querySelectorAll('[data-js-today]');
    // TODO: 英語版対応
    const errorMsg = '件数取得エラーが発生しました';
    // const loader = target.querySelector('[data-js-loader]')

    // エラーハンドリング
    const errorHandler = err => {
      console.error(err);
      target.insertAdjacentHTML('beforeend', `<p class="u-color-alert u-fz-14 u-ta-center">${errorMsg}</p>`);
    };

    // コンテンツを挿入
    const insertContent = html => {
      const domParser = new DOMParser();
      const htmlElement = domParser.parseFromString(html, "text/html");
      // console.log(htmlElement)
      // const contents = htmlElement.querySelectorAll(elementClass)
      const data = JSON.parse(htmlElement.querySelector(dataID).textContent);
      console.log(data);
      // loader.remove()
      targetElements.forEach(element => {
        console.log(element);
        element.textContent = data[element.dataset.jsToday];
      });
      // contents.forEach(content => {
      //   target.insertAdjacentElement('beforeend', content)
      // })
    };

    // IDEA: https://stackoverflow.com/a/50812705
    const fetchContent = async () => {
      try {
        const response = await fetch(fetchURL);
        if (response.ok && response.status !== 404) {
          const html = await response.text();
          // console.log(html)
          insertContent(html);
        } else {
          throw new Error('fetch error')
        }

      } catch (err) {
        errorHandler(err);
      }
    };
    const init = async () => {
      fetchContent();
    };

    init();
  };

  // 物件スライダー
  const rf_prop_slider = () => {
    const propSliders = document.querySelectorAll('[data-js-prop-slider]');
    let sliders = {};

    const args = {
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
      },
      pagination: {
        el: ".c-prop-slider__pagination",
        type: "progressbar",
      },
      breakpoints: {
        0: {
          spaceBetween: 16,
          slidesPerView: 1.2,
          slidesOffsetBefore: 32,
          slidesOffsetAfter: 32,
        },
        768: {
          spaceBetween: 24,
          slidesPerView: 4.4,
          slidesOffsetBefore: 40,
          slidesOffsetAfter: 40,
        },
      },
    };

    const setSwiper = () => {
      propSliders.forEach(slider => {
        const propSlider = new Swiper(slider, args);
        sliders[slider.id] = propSlider;
      });
    };

    const init = () => {
      setSwiper();
    };

    init();

  };

  // お部屋リスト


  // 部屋リストリンク
  const rf_room_list_link = () => {
    const links = document.querySelectorAll('[data-js-room-link]');

    links.forEach(link => {
      link.addEventListener('click', e => {
        e.stopPropagation();
        const clicked = e.target;

        if (
          clicked.tagName === 'A' ||
          clicked.tagName === 'BUTTON' ||
          clicked.hasAttribute('data-js-madori-modal') || //間取り画像の場合
          clicked.closest('.swiper-initialized') //動いているswiperは中止対象
        ) {
          console.log('インタラクティブ要素or間取り画像なので中止');
          return
        }

        const target = link.dataset.jsRoomLink;
        window.open(target, '_blank');
      });
    });
  };

  // お部屋リストの制御
  const rf_room_list_toggle = () => {
    const openClass = '--is-open';
    let tempText = '';
    const maxHeightPC = 660;
    const maxHeightSP = 1200;
    const toggles = document.querySelectorAll('[data-js-room-toggle]');


    // トグルボタンのコントロール, 画像の読み込みなどを考慮してwindowロード後
    window.addEventListener('load', () => {
      toggles.forEach(toggle => {
        const target = document.querySelector(toggle.dataset.jsRoomToggle);

        // トグルボタンの表示・非表示をまず決める（デフォルト: 表示）
        if (rf_get_globals('window_state') === 'PC' && target.scrollHeight < maxHeightPC) {
          toggle.classList.add('--is-hide');
        } else if (rf_get_globals('window_state') === 'SP' && target.scrollHeight < maxHeightSP) {
          toggle.classList.add('--is-hide');
        }

        // クリックコントロール
        toggle.addEventListener('click', () => {

          target.classList.toggle(openClass);
          toggle.classList.toggle(openClass);

          // 高さ
          if (target.classList.contains(openClass)) {
            target.style.maxHeight = target.scrollHeight + 'px';
          } else {
            target.style.maxHeight = null;
          }


          // テキスト
          if ('jsRoomToggleText' in toggle.dataset) {
            tempText = toggle.textContent;
            toggle.textContent = toggle.dataset.jsRoomToggleText;
            toggle.dataset.jsRoomToggleText = tempText;
          }
        });
      });
    });

  };

  // 建物・部屋 詳細ページ共通

  // =======================================================
  // NEW 建物・部屋スライド
  // 参考: https://codepen.io/tea4two/pen/LYvLNME?editors=0010
  class RFBuildroomSlide {
    #swipers = {
      //Swiperスライドオブジェクト保管用
      mainSlide: null,
      thumbSlide: null,
      modalMainSlide: null,
      modalThumbSlide: null,
    }

    // ローダー
    #loader = null

    // 一度取得したスライドのデータ(JSON)
    // 順番(厳守): 1 建物, 2 間取り, 3 部屋 , 4 外観・共用部・周辺環境写真, 5 パノラマ 
    #photos = {
      build: [],//建物（メイン）
      floorplan: [], //間取り・部屋
      // room: [],//部屋
      exterior: [],//外観・共用部・周辺環境写真
      panorama: [],//パノラマ、動画
      // nophoto: [], // no photo
    }

    // 一度作成したスライドHTMLデータ
    #photoHTML = {
      build: [],//建物(メイン)
      exterior: [],//外観・共用部・周辺環境写真
      floorplan: [], //間取り・部屋
      // room: [],//部屋
      panorama: [],//パノラマ、動画
    }

    // タブボタン文言
    #tabBtnTexts = {
      ja: {
        build: '建物',
        exterior: '外観・共用部・周辺',
        // ↓部屋ページ専用
        floorplan: '間取り・部屋',
        // room: '部屋',
        // ↓ページ共通
        panorama: 'パノラマ・動画',
      },
      en: {
        build: 'Building',
        exterior: 'Exterior, common spaces, and surroundings',
        // ↓部屋ページ専用
        floorplan: 'Floor plan &amp; Room',
        // room: 'Room',
        // ↓ページ共通
        panorama: 'Panoramas and videos',
      }
    }

    // 現在のスライド
    #currentSlide = null

    // 間取り0件フラグ
    #isFloorData = true

    // 画像ロードエラーフラグ
    #isPhotosLoaded = {
      build: true,
      floorplan: true, //間取り・部屋
      // room: true,
      exterior: true,
      panorama: true,
    }
    
    // メインスライド（Swiper）設定
    #swiperMainSetting = {
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev"
      },
      pagination: {
        el: ".swiper-pagination",
        type: "fraction",
      },
    }
    // サムネイルスライド(Swiper)設定
    #swiperThumbsSetting = {
      slidesPerView: 4.5,
      freeMode: true,
      spaceBetween: 8,
      breakpoints: {
          0: {
            slidesPerView: 4.5,
          },
          768: {
            slidesPerView: 8.5,
          },
        },
    }

    //モーダルサムネイルスライド(Swiper)設定
    #swiperModalThumbsSetting = {
      slidesPerView: 4.5,
      freeMode: true,
      spaceBetween: 8,
      breakpoints: {
          0: {
            slidesPerView: 4.5,
          },
          768: {
            slidesPerView: 12.5,
          },
        },
    }
    // エラー ===
    #errorMessages = {
      ja: {
        nodata: 'データを取得できません',
      },
      en: {
        nodata: 'Failed to get data',
      }
    }

    // 要素 ===
    // メイン
    #mainSlideParent = document.querySelector("[data-js-buildroom-slide]");
    #mainSlideContainer = this.#mainSlideParent.querySelector("[data-js-buildroom-slide-container]");
    #mainSlideElm = this.#mainSlideParent.querySelector(".swiper");
    #slideWrapper = this.#mainSlideElm.querySelector(".swiper-wrapper");
    // サムネイル
    #thumbSlideContainer = this.#mainSlideParent.querySelector("[data-js-buildroom-slide-thumbs-container]");
    #thumbElm = this.#mainSlideParent.querySelector("[data-js-buildroom-slide-thumbs]");//.swiper
    #thumbWrapper = this.#thumbElm.querySelector(".swiper-wrapper");
    // モーダル
    #modalSlideWindow = document.querySelector("[data-js-buildroom-modal]")
    #modalSlideElm = this.#modalSlideWindow.querySelector(".swiper");
    #modalSlideWrapper = this.#modalSlideElm.querySelector(".swiper-wrapper");
    // モーダルサムネイル
    #modalThumbElm = this.#modalSlideWindow.querySelector('[data-js-buildroom-modal-thumbs]')
    #modalThumbWrapper = this.#modalThumbElm.querySelector(".swiper-wrapper");

    //モーダル開くボタンHTML
    #btnOpenModalHTML = `<button class="c-buildroom-slide__btn-open --modal --is-hidden" data-js-buildroom-modal-open data-js-modal type="button">
    <span class="u-visually-hidden">拡大</span>
    </button>`
    #btnOpenModal = null

    // パノラマ・ムービーを開くボタン
    #btnOpenPanoramaHTML = `<button class="c-buildroom-slide__btn-open --panorama --is-hidden" data-js-buildroom-panorama-open type="button">`
    #btnOpenPanorama = null

    //タブ
    #mainSlideTabContainer = document.querySelector('[data-js-buildroom-slide-tab-container]')
    #mainSlideTabs = null

    // nodata画像(ファイル側へ移動)
    // RF_gallery_nophoto = '/assets/img/common/nophoto.webp'
    // RF_gallery_nofloorplan = '/assets/img/common/nofloorplan.webp'

    // ===

    // 初期化
    constructor() {
      this.#init();
    }

    // ===

    // ❌️. データがない場合の処理（nodata画像を入れる）
    #setNodata() {
      // 固定表示の1枚目を削除
      // https://www.jamesbaum.co.uk/blether/vanilla-js-equivalent-jquery-find-parent-data-remove-class-empty-append/#empty
      while(this.#slideWrapper.firstChild) {
        this.#slideWrapper.removeChild(this.#slideWrapper.firstChild);
      }

      // nodata画像を追加
      const imgHTML = `<div class="swiper-slide"><img src="${RF_gallery_nophoto}" alt="No photo" class="c-buildroom-slide__nodata"></div>`;
      this.#slideWrapper.insertAdjacentHTML('beforeend', imgHTML);

      // Swiper関連の要素を非表示
      this.#mainSlideParent.classList.add('--is-slide-disabled');

    }

    // ❌️. エラーメッセージHTML作成
    #setErrorHTML(type) {
      RF_lang;
      const html = `<p class="c-buildroom-slide__error">${this.#errorMessages[RF_lang][type]}</p>`;
      return html
    }

    // ❌️. エラーハンドラー - データがない場合
    // エラータイプ: nodata, ...
    #errorHandler(type) {

      // 完全にデータが無い場合(blade側で処理するため多分使用しない)
      if(type === 'nodata')  {
        this.#setErrorHTML(type);
        this.#setNodata();
      }
    }

    // ===
    // 🔁 ローダー
    // ↓未使用なので一旦停止
    // #setSkeltonLoader() {
    //   this.#mainSlideContainer.classList.add('--is-active')
    // }
    #removeSkeltonLoader() {
      this.#mainSlideContainer.classList.remove('--is-loading');
    }

    // ===

    // 💡. 現在のスライドの種類の設定
    #setCurrentSlide(key) {
      this.#currentSlide = key;
    }

    // 💡. 現在のスライドの種類の取得
    #getCurrentSlide() {
      return this.#currentSlide
    }

    /**
     * 💡. スライドデータ（JSON）を取得
     * 
     * @param {string} key - スライドの種類キー
     * @returns {object} - スライドデータ(配列)
     */
    #getSlideData(key) {
      return this.#photos[key]
    }

    /**
     * 
     * @param {string} key スライドの種類キー
     * @param {object} data スライドデータ(配列)
     */
    #setSlideData(key, data) {
      this.#photos[key] = data;
    }

    // 💡. スライドHTMLデータ(配列)を取得
    #getSlideHTMLData(key) {
      return this.#photoHTML[key];
    }

    // 💡. スライドHTML(配列)をまとめて追加
    #setSlideHTMLData(key, data) {
      this.#photoHTML[key] = data;
      console.log('スライドHTML: ', this.#photoHTML);
    }
    // 💡. スライドHTML(文字列)を取得
    // #getSlideHTML(key) {
    //   const photoArr = this.#getSlideHTMLData(key);
    //   let slideHTML = "";
    //   photoArr.forEach(photoHTML => {
    //     slideHTML += photoHTML;
    //   });
    //   return slideHTML;
    // }

    // 💡. 間取り写真なしの処理
    #removeNoFloorDataProcess() {
      console.log('サムネイルコンテナを表示します。');
      // サムネイルコンテナを隠す
      this.#thumbSlideContainer.classList.remove('--is-hidden');
    }
    #setNoFloorDataProcess() {
      console.log('間取り画像がありません。モーダル、タブボタンを非表示にします。');
      // モーダルボタンorパノラマオープンボタンを非表示
      this.#showHideModalBtn(false);

      // Swiperを無効化する
      this.#swipers.mainSlide.disable();
      this.#swipers.thumbSlide.disable();

      // サムネイルコンテナを隠す
      this.#thumbSlideContainer.classList.add('--is-hidden');
      
    }

    // 画像ロードエラーの場合の処理 ===
    /**
     * 画像ロードエラーで非表示にしたサムネイルコンテナを表示
     */
    #removeErrorDataProcess() {
      console.log('サムネイルコンテナを表示します。');
      // サムネイルコンテナを隠す
      this.#thumbSlideContainer.classList.remove('--is-hidden');
    }
    /**
     * 画像ロードエラーの場合の処理 - モーダルボタン、サムネイルコンテナを非表示、Swiperを無効化
     */
    #setErrorDataProcess() {
      console.log('画像がありません。ボタン系を非表示にします。');
      // モーダルボタンorパノラマオープンボタンを非表示
      this.#showHideModalBtn(false);

      // Swiperを無効化する
      this.#swipers.mainSlide.disable();
      this.#swipers.thumbSlide.disable();

      // サムネイルコンテナを隠す
      this.#thumbSlideContainer.classList.add('--is-hidden');
    }

    /**
     * 💡. スライドを全撤去
     */
    #removeAllSlides() {
      this.#swipers.mainSlide.removeAllSlides();
      this.#swipers.thumbSlide.removeAllSlides();
      this.#swipers.modalMainSlide.removeAllSlides();
      this.#swipers.modalThumbSlide.removeAllSlides();
    }

    /**
     * 💡. モーダル開く、パノラマ開くボタンの表示・非表示
     * @param {bool} is_show 
     * @param {bool} is_panorama 
     */
    #showHideModalBtn(is_show = false, is_panorama = false) {
      const hideCls = '--is-hidden';

      if(is_show) {
        // 表示
        console.log('モーダルかパノラマオープンボタンを表示します');
        if(is_panorama) {
          console.log('パノラマオープンボタン表示');
          this.#btnOpenModal.classList.add(hideCls);
          this.#btnOpenPanorama.classList.remove(hideCls);
        } else {
          console.log('モーダルオープンボタン表示');
          this.#btnOpenModal.classList.remove(hideCls);
          if(this.#photos.panorama.length > 0) {
            this.#btnOpenPanorama.classList.add(hideCls);
          }
        }

      } else {
        // 非表示
        console.log('モーダル、パノラマオープンボタンを非表示にします');
        this.#btnOpenModal.classList.add(hideCls);
        if(this.#photos.panorama.length > 0) {
          this.#btnOpenPanorama.classList.add(hideCls);
        }
      }
    }

    
    /**
     * 💡. モーダルスライドを追加（モーダル開くボタンから呼び出し）
     * 
     * メモ: モーダルスライドの追加・更新はモーダルが表示されてから行う (display: noneの状態ではSwiperの追加・更新が正常に行われないため)
     * @param {int} activeIndex 
     */
    #setModalSlide(activeIndex) {
      console.log('モーダルスライドを追加 key: ', this.#getCurrentSlide());
      const key = this.#getCurrentSlide();

      // モーダルのスライドを全撤去
      this.#swipers.modalMainSlide.removeAllSlides();
      this.#swipers.modalThumbSlide.removeAllSlides();

      // モーダルスライド用にデータを取得
      const data = this.#getSlideHTMLData(key);

      // モーダルスライドの追加と更新
      this.#swipers.modalMainSlide.appendSlide(data);
      this.#swipers.modalThumbSlide.appendSlide(data);
      
      this.#swipers.modalThumbSlide.update();
      this.#swipers.modalMainSlide.update();

      this.#swipers.modalMainSlide.slideTo(activeIndex);
      this.#swipers.modalThumbSlide.slideTo(activeIndex);
    }


    /**
     * 💡. Swiperスライドの設定
     * @param {string} key 現在のスライドキー
     */
    #setSwiperSlide(key) {
      console.log('Swiperにスライド追加！');
      // 1. 全撤去
      this.#removeAllSlides();

      // 2. データを取得
      const data = this.#getSlideHTMLData(key); //getSlideData()はJSONを返すのでappendできないので、配列HTMLデータを入れる

      // 3. スライド追加
      // メインスライド
      this.#swipers.thumbSlide.appendSlide(data);
      this.#swipers.thumbSlide.update();
      this.#swipers.thumbSlide.slideTo(0);

      this.#swipers.mainSlide.appendSlide(data);
      this.#swipers.mainSlide.update();
      this.#swipers.mainSlide.slideTo(0);

      // モーダルスライドの更新はモーダルオープンボタンを押してから

      // Swiperを有効化する
      // setTabBtnEvent関数でSwiperが無効化されている場合があるので有効化する
      console.log('setSwiper', this.#isPhotosLoaded[key]);
      if(this.#isPhotosLoaded[key]) {
        this.#swipers.mainSlide.enable();
        this.#swipers.thumbSlide.enable();
        
        // 1つ前の処理で、間取り写真がない場合はサムネイルが非表示になっている場合があるので表示する
        this.#removeNoFloorDataProcess();

        // モーダルボタンorパノラマオープンボタンを表示
        this.#showHideModalBtn(true, key === 'panorama');
      }

      // 現在のスライドの種類を更新
      this.#setCurrentSlide(key);
    }


    /**
     * 💡. SwiperのスライドHTMLに変換して配列化する
     * @param {array} photos 写真データ配列
     * @param {boolean} is_panorama パノラマ写真かどうか
     * @returns {array} スライドHTML化したものを配列で返す(Swiperスライド形式)
     */
    #convertToSwiperHTML(photos, is_panorama = false) {
      let dataArr = [];
      //パノラマ写真の場合
      // let panoramaClass = (is_panorama) ? 'data-js-buildroom-panorama' : '';

      photos.forEach(photo => {
        // console.log(is_panorama)
        // console.log(photo)
        let panoramaAttr = '';
        //パノラマ・動画ならばdata-js-buildroom-panorama属性と値を追加
        if(is_panorama) {
          panoramaAttr = `data-js-buildroom-panorama="${photo.url}"`;
        }

        // Swiper slideテンプレ
        const nophoto = RF_page_key === 'build' ? RF_gallery_nophoto : RF_gallery_nofloorplan;
        dataArr.push(
          `<div class="swiper-slide" ${panoramaAttr}><img src="${(is_panorama) ? photo.filename : photo}" alt="" class="" loading="lazy" onerror="this.onerror='';this.src='${nophoto}'"></div>`
        );
      });

      return dataArr;
    }

    /**
     * 画像のデコード
     * 
     * 画像が読み込まれているかどうかをチェックするためデコードする
     * @param {object} img HTML img element
     */
    async #imageDecode(img) {
      await img.decode();

      console.log(`width: ${img.width}, height: ${img.height}`);
    }

    /**
     * 💡. 画像ロード状況チェック
     * 
     * @param {object} photos 
     * @param {boolean} is_panorama 
     * @returns 
     */
    async #checkPhotoLoad(photos, is_panorama = false) {
      let counter = 0;
      let errorCounter = 0;
      let min = 0;
      const limit = 3;
      min = (photos.length > limit) ? limit : photos.length;
      const timeLimit = 30000;
      console.log('チェックする画像の枚数',  min);

      // https://www.w3schools.com/js/js_async.asp
      let loaded = new Promise((resolve, reject) => {
        
        photos.forEach(async (elm) => {
          console.log(elm);
          // Async image load
          // https://stackoverflow.com/a/64747517
          //decode method takes some time to resolve so use await
          const img = new Image();
          if(is_panorama) {
            img.src = elm.filename;
          } else {
            img.src = elm;
          }

          // 画像ロードエラー（４０４など）
          // img.onerror = () => {
          //   console.log('イメージロードで何らかのエラー')
          //   errorCounter++

          //   if(errorCounter >= min) {
          //     reject(false);
          //   }

          //   return
          // };

          try {
            counter++;
            console.log('画像カウンター: ', counter);

            await this.#imageDecode(img);

            if (counter >= min) {
              resolve(true);
            }

          } catch(err) {
            // 画像のデコードができない（画像が404、ネットワークエラー等）
            console.log(err);
            errorCounter++;

            if(errorCounter >= min) {
              reject(true);
            }

            if (counter >= min) {
              console.log('エラーありでcounter終了');
              resolve(true);
            }
          }

        });

        setTimeout(() => {
          reject(false);
        }, timeLimit); //timeLimit以内に解決しなければfalse
      });

      return await loaded;
    };


    /**
     * 写真のロードをチェックし、スライドHTMLを作成する
     * 
     * @param {string} key スライドの種類キー
     */
    async #checkLoadAndSetSlideHTML(key) {
      let slideHTMLData = null;

      const photoData = this.#getSlideData(key);
      // const data = this.#convertToSwiperHTML(photoData, key === 'panorama');
      // 配列にHTMLデータを追加
      // this.#setSlideHTMLData(key, data)

      // 初期写真データロードチェック
      // TODO: ロードチェックはソートのあとに実施する
      try {
        const loaded = await this.#checkPhotoLoad(photoData, key === 'panorama');
        
        // 成功時
        console.log('loaded: ', loaded);
        console.log(photoData);
        slideHTMLData = this.#convertToSwiperHTML(photoData, key === 'panorama');
        
      } 
      catch (loadError) {
        console.log('初期写真の取得に失敗');
        console.error(loadError);

        // 取得エラーを起こした場合、何も表示されないとまずいので、nophoto画像に差し替える
        // checkPhotoLoadのrejectからtrueが返される
        if(loadError) {
          console.log('写真取得に失敗。no photoに差し替えます');
          // this.#setSlideData(key, [RF_gallery_nophoto])
          this.#photos[key] = [{
            filename: RF_gallery_nophoto
          }];

          // データ取り直し
          const data = this.#getSlideData(key);
          slideHTMLData = this.#convertToSwiperHTML(data);

          // 画像ロードエラーフラグを設定
          // this.#isLoaded = false
          this.#isPhotosLoaded[key] = false;
        }
        
      }
      finally {
        // 画像がno photoのみの場合、Swiperをセットしない
        const registeredPhoto = this.#photos[key][0].substring(this.#photos[key][0].lastIndexOf('/') + 1);
        const defaultNoPhoto = RF_gallery_nophoto.substring(RF_gallery_nophoto.lastIndexOf('/') + 1);
        if(
          this.#photos[key].length === 1 && 
          registeredPhoto === defaultNoPhoto
        ) {
          console.log('no photoのみです');
          this.#isPhotosLoaded[key] = false;
        }

        // HTMLデータ配列を追加
        console.log('スライドHTMLデータをセットします: ', slideHTMLData);
        this.#setSlideHTMLData(key, slideHTMLData);

      }

    }

    // 💡. ムービー、パノラマの別ウィンドウ開く設定
    #openPanoramaWindow() {
      const windowSetting = 'width=800,height=600,left=0,top=0,menubar=no,status=no';
      // 現在表示中のスライド要素を取得
      const activeSlide = this.#mainSlideElm.querySelector('.swiper-slide-active');
      const url = activeSlide.dataset.jsBuildroomPanorama;
      console.log(url);
      window.open(url, '', windowSetting);
    }

    // 💡. パノラマオープンボタンの設定
    #setPanoramaOpenBtn() {
      console.log('パノラマオープンボタンの追加');
      // パノラマオープンボタンの追加
      this.#mainSlideContainer.insertAdjacentHTML('beforeend', this.#btnOpenPanoramaHTML);
      this.#btnOpenPanorama = this.#mainSlideContainer.querySelector('[data-js-buildroom-panorama-open]');
      // this.#btnOpenPanorama.classList.add('--is-hidden')

      // イベントリスナーの設定
      // このボタンは別ウィンドウでムービー、パノラマを開く
      // メインのSwiper要素に設定されている data属性の値を取ってきて、別ウィンドウで開く
      this.#btnOpenPanorama.addEventListener('click', () => {
        // const url = this.#swipers.mainSlide
        this.#openPanoramaWindow();
      });
    }

    // 💡. モーダルオープンボタン
    #setModalOpenBtn() {
      this.#mainSlideContainer.insertAdjacentHTML(
        "beforeend", this.#btnOpenModalHTML
      );
      this.#btnOpenModal = this.#mainSlideContainer.querySelector('[data-js-buildroom-modal-open]');
      this.#btnOpenModal.dataset.jsModal = '#' + this.#modalSlideWindow.id; //対象のIDを設定
    }

    // ===

    /**
     * 7-2. タブボタンイベントの設定
     * 
     */
    #setTabBtnEvent() {
      this.#mainSlideTabs.forEach(btn => {
        // const key = btn.dataset.jsBuildroomSlideTab
        // let data = null
        let is_loading = false;

        btn.addEventListener('click', async (e) => {
          const key = e.target.dataset.jsBuildroomSlideTab;

          // ロード中なのでストップ
          if(is_loading) {
            console.log('ロード中なのでストップ');
            return
          }

          // ロード開始をフラグで管理
          is_loading = true;

          console.log('タブイベント',  key, this.#isFloorData);

          // 同じボタンをクリックした場合は処理しない
          if (this.#getCurrentSlide() === key) {
            console.log("同じボタンなのでストップ");
            is_loading = false;
            return;
          }

          // 一旦モーダルオープン、パノラマオープンボタンを両方とも非表示
          this.#showHideModalBtn(false);

          // 一旦、Swiperを無効化する
          this.#swipers.mainSlide.disable();
          this.#swipers.thumbSlide.disable();

          // アクティブボタンの切り替え
          this.#mainSlideTabs.forEach(btn => {
            btn.classList.remove('--is-active');
          });
          if(e.target.tagName === 'BUTTON') e.target.classList.add('--is-active'); 

          // データ取得
          if (this.#getSlideHTMLData(key).length) {
            // 取得済みなのでデータからロードし、Swiperを有効化
            console.log("データからロード");
            this.#setSwiperSlide(key);
            
            // 画像のbroken link処理
            if (!this.#isPhotosLoaded[key]) {
              this.#setErrorDataProcess();
            }

            is_loading = false;
          } else {
            // データ取得
            console.log("未HTML化なのでHTML化してロード");
            
            // ローダー設定
            this.#loader.reinsertLoader(); //同じローダーを再挿入
            // this.#setSkeltonLoader()

            const photoData = this.#getSlideData(key);
            const data = this.#convertToSwiperHTML(photoData,key === 'panorama');
            this.#setSlideHTMLData(key, data);

            // ロード
            try {
              const loaded = await this.#checkPhotoLoad(photoData, key === 'panorama');

            } catch (error) {
              console.log('ロードに失敗しました');
              console.log(error);            

            } finally {
              console.log('ロードされました');

              // ローダー削除
              this.#loader.removeLoader();
              this.#removeSkeltonLoader();

              // Swiperを有効化する
              this.#setSwiperSlide(key);

              // 画像のbroken link処理
              if (!this.#isPhotosLoaded[key]) {
                this.#setErrorDataProcess();
              }

              is_loading = false;
            }
          }

        });
      });
    }

    /**
     * 7-1. タブボタン要素の作成
     * 
     * @param {string} key 
     * @returns {string} 1つのタブボタン要素(HTML)
     */
    #createTabHTML(key) {
      let lang = RF_lang;
      return `<button type="button" data-js-buildroom-slide-tab="${key}" type="button">${this.#tabBtnTexts[lang][key]}</button>`
    }

    // 
    /**
     * 7.タブの設定
     */
    #setTabs() {
      let tabHTML = '';
      for(let key in this.#photos) {
        // if (!this.#photos.hasOwnProperty(key)) continue;

        // 建物ページか部屋ページを判定
        // 建物↓
        if(
          RF_page_key === 'build' && 
          (
            key === 'build' || 
            key === 'exterior' || 
            key === 'panorama'
          )
        ) {
          // console.log('タブ: 建物です')
          if(this.#photos[key].length > 0) tabHTML += this.#createTabHTML(key);
        }
        // 部屋↓
        else if(
          RF_page_key === 'room' &&
          (
            key === 'room' || 
            key === 'exterior' || 
            key === 'floorplan' || 
            key === 'panorama'
          )
        ) {
          // console.log('タブ: 部屋です')
          if(this.#photos[key].length > 0) tabHTML += this.#createTabHTML(key);
        }

      }
      // タブHTMLの挿入、登録
      this.#mainSlideTabContainer.insertAdjacentHTML('beforeend', tabHTML);
      this.#mainSlideTabs = Array.from(this.#mainSlideTabContainer.querySelectorAll("[data-js-buildroom-slide-tab]"));

      // 最初のタブにactiveクラスを付与
      const key = this.#getCurrentSlide();
      console.log('タブ用のkey: ', key);
      const activeTab = this.#mainSlideTabs.filter(tab => tab.dataset.jsBuildroomSlideTab === key);
      activeTab[0].classList.add('--is-active');
      
      // 7-2. タブボタンイベントの設定
      this.#setTabBtnEvent();
    }

    // ===
    
    /**
     * 6-1.モーダルオープンボタンを押したとき、アクティブインデックスを更新するイベントを設定
     * 
     * モーダルのSwiperをメインSwiperと同期させるため
     */
    #setModalActiveIndex() {
      this.#btnOpenModal.addEventListener('click', () => {
        console.log('モーダルアクティブインデックスを更新、モーダルスライドを追加');
        this.#setModalSlide(this.#swipers.mainSlide.activeIndex);
      });
    }

    /**
     * 6. モーダルウィンドウの制御
     * 
     * モーダル開くボタン、パノラマ・動画ボタンの追加(存在すれば)
     */
    #setModalWindowAction() {
      // ⏹️モーダル開くボタン追加
      this.#setModalOpenBtn();

      // ⏹️パノラマ・動画が存在すれば、パノラマオープンボタン追加
      if(this.#photos.panorama.length > 0) {
        this.#setPanoramaOpenBtn();
      }

      // 現在のスライドの種類に合わせて、モーダルかパノラマオープンボタンを表示
      const key = this.#getCurrentSlide();
      this.#showHideModalBtn(true, key === 'panorama');

      // モーダルオープンボタンの設定(RfModalsを使用)
      const _modalArgs = {
        modal: this.#modalSlideWindow,
        modalOpenBtn: this.#btnOpenModal,
      };
      if(RF_GLOBALS.rf_modals) {
        console.log('モーダル作成: すでにモーダルインスタンスがあります。');
        RF_GLOBALS.rf_modals.modal(_modalArgs);
      } else {
        console.log('モーダル作成: モーダルインスタンスはありません。作成します');
        RF_GLOBALS.rf_modals = new RF_GLOBALS.RfModals(_modalArgs);
      }

      // 6-1. モーダル開くボタンクリックイベントの設定
      this.#setModalActiveIndex();
    }

    // ===

    // 5. Swiper初期化（初回のみ）
    #setSwiper() {
      console.log('Swiper初期化');
      // メインサムネイル
      this.#swipers.thumbSlide = new Swiper(this.#thumbElm, this.#swiperThumbsSetting);

      // メイン
      let swiperMainSetting = {
        ...this.#swiperMainSetting,
        // サムネイルと連動
        thumbs: {
          swiper: this.#swipers.thumbSlide,
        }
      };
      this.#swipers.mainSlide = new Swiper(this.#mainSlideElm, swiperMainSetting);


      // モーダルサムネイル
      this.#swipers.modalThumbSlide = new Swiper(this.#modalThumbElm, this.#swiperModalThumbsSetting);


      // モーダルメイン
      let swiperModalMainSetting = {
        ...this.#swiperMainSetting,
        // サムネイルと連動
        thumbs: {
          swiper: this.#swipers.modalThumbSlide,
        }
      };
      this.#swipers.modalMainSlide = new Swiper(this.#modalSlideElm, swiperModalMainSetting);
      

      // コントロール連携
      this.#swipers.modalThumbSlide.controller.control = [this.#swipers.thumbSlide]; //サムネイル ↔ モーダルサムネイル
      this.#swipers.thumbSlide.controller.control = [this.#swipers.modalThumbSlide]; // モーダルサムネイル ↔ サムネイル
      this.#swipers.mainSlide.controller.control = [this.#swipers.modalMainSlide]; // モーダルメイン ↔ メイン
      this.#swipers.modalMainSlide.controller.control = [this.#swipers.mainSlide]; // メイン ↔ モーダルメイン

      // 6以降の処理をsetInitPhotosへ移動    

    }

    // ===

    // 4. 初回SwiperのスライドHTML配列を文字列化して挿入する
    #insertInitSlides(key) {
      let html = '';

      const arr = this.#getSlideHTMLData(key);

      arr.forEach(data => {
        html += data;
      });

      console.log('初期スライドHTML',html);

      this.#slideWrapper.insertAdjacentHTML('beforeend', html);
      this.#thumbWrapper.insertAdjacentHTML('beforeend', html);
      
    }

    // ===

    // 3. 初期データを処理
    async #setInitPhotos() {
      // 初回のキーチェック
      let firstKey = '';// 初回のキー

      // データの中で最初に空ではないキーをチェックする
      if (RF_page_key === 'build') {
        // (obj) => Object.keys(obj).find((i) => obj[i] === true)
        firstKey = Object.keys(this.#photos).find(key => {
          // 建物では間取りと部屋は除外
          if (
            key === 'floorplan' ||
            key === 'room'
          ) {
            return false
          }

          if (this.#photos[key].length > 0) return true
        });

      } else if (RF_page_key === 'room') {
        // 部屋ページでは常に最初は「間取り・部屋」になる
        firstKey = 'floorplan';
      }
      console.log('firstKey: ', firstKey);
      // 初回のキーチェックここまで ===

      //💡. 現在のスライドの種類をセット
      this.#setCurrentSlide(firstKey);

      // TODO: 画像ロードチェックとスライドHTML作成
      await this.#checkLoadAndSetSlideHTML(firstKey);


      // 固定表示の1枚目を削除
      // https://www.jamesbaum.co.uk/blether/vanilla-js-equivalent-jquery-find-parent-data-remove-class-empty-append/#empty
      while (this.#slideWrapper.firstChild) {
        this.#slideWrapper.removeChild(this.#slideWrapper.firstChild);
      }

      // 4. Swiperの初回スライドHTMLを挿入
      this.#insertInitSlides(firstKey);

      // 5. Swiperを初期化(1回のみ)
      this.#setSwiper();

      // 6.モーダルとパノラマオープンボタンの追加(1回のみ)
      this.#setModalWindowAction();

      // 7.タブの設定
      this.#setTabs();

      // 画像のbroken link処理
      const key = this.#getCurrentSlide();
      if (!this.#isPhotosLoaded[key]) {
        this.#setErrorDataProcess();
      }

      // ローダーを削除
      this.#loader.removeLoader();
      this.#removeSkeltonLoader();
        
    }

    // ===

    /**
     * 2-2. 初期画像を保存
     * 
     * @param {object} filename 画像データURL 
     * @param {string} part 画像種別番号
     */
    #sortFirstDataAndSave(filename, part) {
      switch(part) {
        case '001': //建物メイン写真
          this.#photos.build.push(filename);
          break
        case '101': //間取り写真
          this.#photos.floorplan.push(filename);
          break
      }
    }

    /**
     * 2-2. 部屋ページでの外観データを保存
     * 
     * @param {object} buildData 建物データ配列
     */
    #sortBuildDataAndSave(buildData) {
      // 建物メイン写真がある場合はグローバル変数から配列先頭に保存
      // if(typeof RF_firstbuild_photo !== 'undefined') {
      //   this.#photos.build.unshift(RF_firstbuild_photo)
      // }

      // 建物、外観、共用、周辺写真をまとめてexteriorに格納
      buildData.forEach((elm) => {
        switch(elm.part) {
          // 建物、外観、共用部、周辺
          case '001': //建物メイン写真(部屋ページの場合はJSONから取得)
          case '002':
          case '003':
          case '004':
          case '005':
          case '031':
          case '032':
          case '033':
          case '034':
          case '035':
          case '036':
          case '037':
          case '038':
          case '039':
            this.#photos.exterior.push(elm.filename);
            break;
        }
      });
      console.log('部屋ページ: 建物写真が存在し、挿入後のフォトデータ', this.#photos);
    }

    /**
     * 2-2. 取得したJSONデータをソートし#photosに保存
     * 
     * @param {object} data JSONデータ
     */
    #sortDataAndSave(data) {
      data.forEach((elm) => {
        // console.log(elm.filename)
        switch(elm.part) {
          // 外観
          // case '001': //建物メイン写真(グローバル変数から取得に変更)
          case '002':
          case '003':
          case '004':
          case '005':
            this.#photos.build.push(elm.filename);
            break;
          // 周辺
          case '031':
          case '032':
          case '033':
          case '034':
          case '035':
          case '036':
          case '037':
          case '038':
          case '039':
            this.#photos.exterior.push(elm.filename);
            break;
          // 間取り
          // case '101':
          //   this.#photos.floorplan.push(elm.filename);
          //   break;
          // 部屋
          case '102':
          case '103':
          case '104':
          case '105':
          case '106':
          case '108':
          case '109': 
          case '110': 
          case '111': 
          case '131': 
          case '132': 
          case '133': 
          case '135': 
          case '136': 
          // this.#photos.room.push(elm.filename); //間取りに統合
          this.#photos.floorplan.push(elm.filename);
            break;
        }
      });

      // 部屋ページの間取り写真だけは特別で、写真が無くてもタブ表示し、nophoto画像を挿入する
      // TODO: 削除予定
      console.log('間取り写真枚数', this.#photos.floorplan.length);
      console.log('ソート後の写真データ(this.#photos)', this.#photos);
    }

    /**
     * 2-1. パノラマ・動画のデータを保存(存在すれば)
     * 
     * @return void
     */
    #savePanoramaData() {
      if (typeof RF_gallery_panorama !== 'undefined') {
        RF_gallery_panorama.forEach(elm => {
          this.#photos.panorama.push({
            filename: elm.filename,
            url: elm.url
          });
        });
      }
    }

    /**
     * 2. データ取得
     */
    async #fetchPhotoData() {
      //ローダーを挿入
      this.#loader = new RF_GLOBALS.RfLoader({
        target: this.#slideWrapper,
      });


      // 1. パノラマデータを取得(あれば)
      this.#savePanoramaData();

      // 2. 初期画像データを取得
      // TODO: 1枚目の写真が静的には存在して、JSONに存在しない場合もあるので対応する
      // 例. http://141.147.169.110/rf/tatemono/73682/1700
      let isInitialData = false;
      let img = new Image();
      try {
        if(RF_page_key === 'build') {
          img.src = RF_firstbuild_photo;
        }
        else if(RF_page_key === 'room') {
          img.src = RF_firstfloorplan_photo;
        }

        // 存在チェック
        console.log('初期画像', img);
        await this.#imageDecode(img);

        isInitialData = true;
      }
      catch(err) {
        console.log('初期画像ロードエラー: ', err);

        // no photo画像設定
        if(RF_page_key === 'build') {
          img.src = RF_gallery_nophoto;
          // MEMO: 002~005が存在する場合があるので単純にここでfalseにはできない
          // this.#isPhotosLoaded['build'] = false
        } 
        else if(RF_page_key === 'room') {
          img.src = RF_gallery_nofloorplan;
          // this.#isPhotosLoaded['floorplan'] = false
        }
      }
      finally {
        console.log('ロードチェック後の初期画像', img);
        let part;
        if(RF_page_key === 'build') part = '001';
        else if(RF_page_key === 'room') part = '101';

        this.#sortFirstDataAndSave(img.src, part);
      }

      console.log('初期画像処理後の写真データ(this.#photos)', this.#photos);
      
      
      // 3. その他の画像データを取得
      try {
        // データ: RF_gallery_url
        const fetchedData = await fetch(RF_gallery_url);
        const data = await fetchedData.json();

        console.log('取得した'+ RF_page_key +'データ(JSON): ', data);

        // 部屋ページの場合 - 外観写真データも取得する
        let dataBuild = [];
        if(RF_page_key === 'room') {
          console.log('部屋ページなので、外観写真も取得');
          let fetchedBuildData = await fetch(RF_gellery_tatemono_url);
          dataBuild = await fetchedBuildData.json();
          console.log('【部屋】取得したデータ(外観)(JSON): ', dataBuild);
        }

        // 写真データがまったくない場合は処理をエラー処理へ飛ばす
        // 建物
        if(
          RF_page_key === 'build' && 
          !isInitialData &&
          !data.length && 
          typeof RF_firstbuild_photo === 'undefined'
        ) {
          throw "No data";
        }
        // 部屋
        if(
          RF_page_key === 'room' && 
          !isInitialData &&
          !data.length &&
          !dataBuild.length &&
          typeof RF_firstbuild_photo === 'undefined'
        ) {
          throw "No data";
        }

        //存在すればデータをソート
        this.#sortDataAndSave(data);
        // 部屋ページ専用（外観写真があればソートする）
        if(RF_page_key === 'room' && dataBuild.length > 0) {
          this.#sortBuildDataAndSave(dataBuild);
        }

        // 3. 初期データを挿入
        this.#setInitPhotos();

        // 4~は setInitPhotos内で実行

      } catch (err) {
        console.dir(err);
        // エラーハンドリング - データがない、リファレンスエラー
        this.#errorHandler('nodata');

        this.#loader.removeLoader(); //ローダー削除
        this.#removeSkeltonLoader();
      }
    }

    /**
     * 1. init
     * 
     */
    async #init()  {
      try {
        //2. データ取得
        this.#fetchPhotoData();

      } catch (err) {
        
      }
    }

  }

  // CTAナビ
  const rf_cta_navi_tel = () => {
    // const nav = document.querySelector('.c-cta-navi-tel');
    const btn = document.querySelector(['[data-js-cta-navi-tel]']);
    const nav = document.querySelector(btn.dataset.jsCtaNaviTel);
    
    btn.addEventListener('click', () => {
      console.log(nav);
      nav.classList.toggle('--is-open');
    });

    console.dir(btn);
  };

  const rf_select_link = () => {

    const selectLinks = document.querySelectorAll('[data-js-select-link]');

    selectLinks.forEach(link => {
      link.addEventListener('change', e => {
        const href = e.target.selectedOptions[0].value;
        location.href = href;
      });
    });
  };

  // 関連物件スライダー
  const rf_related_prop_slider = () => {
    const relatedPropSliders = document.querySelectorAll('[data-js-related-prop-slider]');
    const sliders = [];
    const args = {
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
      },
      pagination: {
        el: ".c-prop-slider__pagination",
        type: "progressbar",
      },
      init: false, //あとで発動
      breakpoints: {
        0: {
          spaceBetween: 16,
          slidesPerView: 1.4,
          slidesOffsetBefore: 32,
          slidesOffsetAfter: 32,
        },
        768: {
          spaceBetween: 24,
          slidesPerView: 3.5,
          slidesOffsetBefore: 40,
          slidesOffsetAfter: 40,
        },
      },
    };

    // Swiper設定
    const setSwiper = () => {
      relatedPropSliders.forEach(slider => {
        const relatedPropSlider = new Swiper(slider, args);
        console.dir(relatedPropSlider);
        sliders.push(relatedPropSlider);
      });
      onLoaded();
    };

    // ロード完了アクション
    const onLoaded = () => {
      sliders.forEach(slider => {
        slider.on('init', () => {
          //ローダーを削除
          const loader = slider.el.querySelector('.c-prop-slider__loader');
          if (loader) {
            loader.remove();
          }
        });
        slider.init();
      });
    };

    const init = () => {
      setSwiper();
    };

    init();
  };

  const rf_ward = () => {
    const dataProp = 'jsWardSelect';
    document.querySelector('#sys-form');
    const btns = Array.from(document.querySelectorAll('[data-js-ward-select]'));
    const checkBoxes = btns.filter(btn => btn.tagName === 'INPUT');
    const boundaries = btns.filter(btn => btn.tagName === 'g');
    let currentWards = [];
    let selectedWards = [];
    const toggleClass = '--is-active';

    // 現在選択中の区
    const getWards = () => {
      return selectedWards
    };

    // １つの区
    // const getWard = ward => {

    // }

    const removeWard = ward => {
      const index = selectedWards.indexOf(ward);
      selectedWards.splice(index, 1);
      console.log('削除後', selectedWards);
    };

    // セット
    const setWard = ward => {
      selectedWards.push(ward);
    };

    // 現在の区
    const getCurrentWards = () => {
      return currentWards
    };
    const setCurrentWards = wards => {
      currentWards = [...wards];
      console.log('前の区', currentWards);
    };


    // チェックボックスのトグル
    const toggleCheckbox = (isAdd, dom) => {
      // 差分チェック
      let differences = null;
      if (isAdd) {
        differences = getWards().filter(element => !(getCurrentWards().includes(element)));
      } else {
        differences = getCurrentWards().filter(element => !(getWards().includes(element)));
      }
      console.log('差分', differences);

      //要素チェック
      const isCheckbox = (dom.tagName === 'INPUT');
      console.log('checkbox?', isCheckbox);

      differences.forEach(diff => {
        console.log('差分', diff);
        const [selectedBoundary] = boundaries.filter(bound => bound.dataset[dataProp] === diff);
        const [selectedCheckbox] = checkBoxes.filter(checkbox => checkbox.dataset[dataProp] === diff);
        console.log('選択された', selectedBoundary, selectedCheckbox);
        selectedBoundary.classList.toggle(toggleClass, isAdd);
        selectedCheckbox.checked = isAdd;
      });
    };

    const setToggleAction = () => {
      btns.forEach(btn => {
        btn.addEventListener('click', () => {
          let isAdd = true; // true or false
          setCurrentWards(getWards()); //現在の区を一旦保存
          const ward = btn.dataset.jsWardSelect;
          if (getWards().includes(ward)) {
            console.log('削除');
            isAdd = false;
            removeWard(ward);
          } else {
            console.log('追加');
            setWard(ward);
          }
          console.log('現在', selectedWards);
          console.log('１個前', currentWards);

          // 地図クリックの場合チェックボックスをトグル
          toggleCheckbox(isAdd, btn);
        });
      });
    };

    // すべてのチェックを外す - 画面戻ったときの対策
    const clearAllCheckboxes = () => {
      btns.forEach(btn => {
        console.dir(btn);
        if (btn.tagName === 'INPUT') {
          console.log(btn.checked);
          console.log(btn.defaultChecked);
          btn.setAttribute('autocomplete', 'off');
          btn.checked = false;
        }
      });
    };

    const init = () => {
      // resetForm()
      clearAllCheckboxes();
      // window.addEventListener('load', () => {
      //   console.log('loaded!')
      // })
      setToggleAction();
    };

    init();
  };

  // 検索結果 - お部屋リストスライダー
  const rf_result_room_slide = () => {
    const room_slides = document.querySelectorAll('[data-js-result-room-slide]');
    const pic_area_selector = '[data-js-result-room-parent]';
    const slide_selector_class = 'swiper';
    const slide_wrapper_class = 'swiper-wrapper';
    const disabled_class = '--is-disabled';
    const flash_msg_class = 'c-result-room__flash-msg';

    // const swipers = null //TODO: swiperのインスタンスを保持
    let click_handlers = {};

    // 間取りスライドデータの種類
    const floorplan_type = ['102', '103', '104', '105'];

    const swiper_arg = {
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
      },
      // spaceBetween: 16,
      // slidesOffsetAfter: 16,
      // slidesOffsetBefore: 16,
    };

    const msgs = {
      no_img: 'これ以上画像はありません',
      fetch_err: 'データ取得エラー',
      // no_data: 'データがありません',
    };


    // フラッシュメッセージ
    const insertFlashMessage = (msg, pic_area) => {
      // メッセージを表示中は、追加しない
      if (pic_area.querySelector(`.${flash_msg_class}`)) {
        console.log('Traffic jam right now!!!');
        return
      }
      
      const msg_html = `<p class="${flash_msg_class}">${msg}</p>`;


      pic_area.insertAdjacentHTML('beforeend', msg_html);
      const msg_inserted = pic_area.querySelector(`.${flash_msg_class}`);
      console.log(msg_inserted);


      // remove
      msg_inserted.addEventListener('transitionend', () => {
        msg_inserted.remove();
      });

      // タイマー
      setTimeout(() => {
        msg_inserted.classList.add('--is-deactive');
      }, 3000);

    };

    // 取得エラー
    const handleError = (err_msg, pic_area) => {
      let msg = '';
      // フラッシュメッセージ表示
      switch (err_msg) {
        case 'no_img': //画像が１枚以下
          msg = msgs.no_img;
          pic_area.classList.add('--is-no-slide');
          break
        case 'fetch_err':
          msg = msgs.fetch_err;
          break
        default:
          msg = msgs.fetch_err;
      }
      insertFlashMessage(msg, pic_area);
    };

    // Swiperの設定
    const setSwiper = (data, target_slide) => {
      let html = '';
      data.forEach(item => {
        // <img src="${item.filename}" alt="${item.part}" loading="lazy">
        // エラー画像: ページ側に設定
        html += `<div class="c-result-room__slide-item swiper-slide">
      <img src="${item.filename}" alt="${item.name}" loading="lazy" onerror="this.onerror='';this.src='${RF_gallery_nophoto}'">
      </div>`;
      });

      // const wrapper = target_slide.querySelector(`.${slide_wrapper_class}`)

      // TODO: 間取りは残すのでこの処理は入れない
      // removeAllChildren(target_slide, wrapper)

      const new_wrapper = target_slide.querySelector(`.${slide_wrapper_class}`);
      new_wrapper.insertAdjacentHTML('beforeend', html);

      // Swiper起動
      // TODO: スライダーインスタンスを保管してコントロール可能にするかもしれない
      const swiper = new Swiper(target_slide, swiper_arg);
      swiper.slideTo(1); //２枚目のスライドへ移動させる
    };

    // スライドデータの抽出
    const extractSlideData = (data) => {
      return data.filter(item => floorplan_type.includes(item.part))
    };

    // スライドデータの取得
    const getSlideData = async (url) => {
      try {
        const response = await fetch(url);

        // データ取得エラー
        if (!response.ok) {
          throw new Error('fetch_err')
        }

        const data = await response.json();
        console.log(data);

        const extracted_data = extractSlideData(data);
        console.log(extracted_data);

        // データ数が１の場合スライドさせない
        if (extracted_data.length > 1) {
          return extracted_data
        } else {
          throw new Error('no_img')
        }
      } catch (err) {
        console.dir(err);
        return err.message
      }
    };

    // ボタンクリックアクション
    async function setClickAction(args, event) {
      // console.log(this)
      // console.log('渡されたデータ', args, event)
      const [btn] = args;
      const url = btn.dataset.jsResultRoomSlide;
      const pic_area = btn.closest(pic_area_selector);

      // ボタン無効化中は操作しない
      if (btn.classList.contains(disabled_class)) return false

      // ローダー作成 - _loader.js
      const loader = new RF_GLOBALS.RfLoader({
        target: pic_area
      });

      // ボタン無効化
      btn.classList.add(disabled_class);

      try {
        const data = await getSlideData(url);
        console.log(data);

        // JSONデータかどうかを確認
        if (typeof data === 'object' && JSON.parse(JSON.stringify(data))) {
          // データ取得成功
          const target_slide = btn.closest(`.${slide_selector_class}`);
          const id = btn.dataset.jsResultRoomId;
          btn.removeEventListener('click', click_handlers[id]);

          // ハンドラーをオブジェクトから削除（容量節約のため）
          delete click_handlers[id];
          
          // console.log(click_handlers)
          setSwiper(data, target_slide);
        } else {
          throw new Error(data)
        }
      } catch (err) {
        // なんらかのエラー
        handleError(err.message, pic_area);
      }

      // ボタン有効化
      btn.classList.remove(disabled_class);

      // ローダー削除
      loader.removeLoader();
    }

    const setClickHandler = (btn) => {
      const id = btn.dataset.jsResultRoomId;
      // bindを使用した場合、別関数になるのでremoveEventListenerできない。故にbindしたもの保存して使う
      click_handlers[id] = setClickAction.bind(null, [btn]);
      console.log(click_handlers);
      btn.addEventListener('click', click_handlers[id]);
      btn.click();
      // const clickEvent = new Event('click')
      // btn.dispatchEvent(clickEvent)
    };

    // ボタンクリックイベント設定
    const setSlideAction = () => {
      room_slides.forEach(btn => {
        btn.addEventListener('click', () => {
          setClickHandler(btn);
        }, {
          once: true
        });
      });
    };

    const init = () => {
      setSlideAction();
    };

    init();
  };

  // 検索 - 駅・沿線

  const rf_search_ensen_checkbox = () => {
    const forms = document.querySelectorAll('[data-js-form-checkbox]');
    const form_ensen_step_one_id = 'form-ensen-step1';
    const form_ensen_steps_id = [
      form_ensen_step_one_id,
    ];
    const btn_search_id = 'form-ensen-submit';
    const btn_disabled_class = '--is-disabled';
    let checkboxes = [];

    // 選択・検索ボタンのクラスをトグル
    const toggleBtnClass = (el, status) => {
      const is_disabled = !status;
      el.classList.toggle(btn_disabled_class, is_disabled);
      if (is_disabled) {
        el.setAttribute('disabled', 'disabled');
      } else {
        el.removeAttribute('disabled');
      }
    };

    // チェックボックス操作のコールバック関数
    function checkboxCallback() {
      console.log(this);
      const obj = this;
      const status = obj.checker.getStatus();
      const formId = obj.formId;

      switch (formId) {
        // 沿線の選択の場合 - 選択・検索ボタンのクラスをトグル
        case form_ensen_step_one_id:
          const el = document.querySelector(`#${btn_search_id}`);
          toggleBtnClass(el, status);
      }
    }

    // チェックボックスのステータスチェック
    const checkboxStatus = () => {
      if (checkboxes.length === 0) return
      checkboxes.forEach(obj => {
        const cb = checkboxCallback.bind(obj);
        obj.elements.forEach(checkbox => {
          checkbox.addEventListener('change', cb);
        });
        // １つだけ取り出して、初期チェックを走らせる
        obj.elements[0].dispatchEvent(new Event('change'));
      });
    };

    // チェックボックスの取得
    const getCheckboxes = (forms) => {

      forms.forEach(form => {
        const id = form.id;
        let _checkboxes;

        try {
          if (!id) {
            throw new Error('Please provide form id')
          }
          // そもそもチェックボックスの確認対象のフォームかどうか調べる
          if (!form_ensen_steps_id.includes(id)) {
            throw new Error('This form is not set for checkbox checks')
          }
          // チェックボックス取得 - 対象のものだけ
          _checkboxes = form.querySelectorAll('input[type=checkbox][data-js-checkbox-target]');
          if (_checkboxes.length === 0) {
            throw new Error('Target checkbox does not exist.')
          }
        } catch (err) {
          console.log(err.message);
          return
        }

        checkboxes.push({
          formId: id,
          checker: new RF_GLOBALS.RfCheckboxStatus(form, _checkboxes),
          elements: _checkboxes,
        });

      });

      checkboxStatus();

    };




    const init = () => {
      getCheckboxes(forms);
    };

    init();

  };

  class RfMediaQuery {
    #cb
    #event
    #minWidth = 768
    #query = matchMedia(`(min-width: ${this.#minWidth}px)`);

    constructor(cb, event, minWidth = this.#minWidth) {
      this.#cb = cb;
      this.#event = event;
      this.#minWidth = minWidth;
      this.#query = matchMedia(`(min-width: ${minWidth}px)`);
      this.#attachListener();
    }

    #attachListener() {
      console.log('media query function: ', this.#cb);
      this.#query.addEventListener(this.#event, this.#cb);
      this.#query.dispatchEvent(new Event(this.#event)); //初回限定
    }
  }

  // 検索方法・選び方の変更のtippy展開
  const rf_search_change_method = () => {
    const btn = document.querySelector('[data-js-search-change-method]');
    let tippyInstance;
    const tippyFunc = (ref) => {
      const id = ref.dataset.jsSearchMethod;
      document.querySelector(id);
      return document.querySelector(id)
    };

    const tippySettingCommon = {
      content: tippyFunc,
      animation: 'shift-away',
      interactive: true,
      interactiveBorder: 10,
      trigger: 'click',
      delay: [null, 300],
      arrow: tippy.roundArrow,
      theme: 'rf',
    };
    const tippySettingSP = {
      placement: 'bottom',
    };
    const tippySettingPC = {
      placement: 'right',
    };

    // メディアクエリのブレイクポイントでtippyの設定を変更する
    const change_tippy_setting = event => {
      console.log('media event', event);
      const is_matched = event.matches || event.currentTarget.matches;
      console.log('is_matched: ', is_matched);
      let tippySetting;
      if (is_matched) {
        console.log('tippy PC');
        tippySetting = {
          // ...tippySettingCommon,
          ...tippySettingPC
        };
      } else {
        console.log('tippy SP');
        tippySetting = {
          // ...tippySettingCommon,
          ...tippySettingSP
        };
      }
      tippyInstance.setProps(tippySetting);
    };

    const set_tippy = () => {
      console.log('tippy init');
      let tippySetting;
      if (RF_GLOBALS.RF_CONFIG['window_state'] === 'PC') {
        tippySetting = {
          ...tippySettingCommon,
          ...tippySettingPC
        };
      } else if (RF_GLOBALS.RF_CONFIG['window_state'] === 'SP') {
        tippySetting = {
          ...tippySettingCommon,
          ...tippySettingSP
        };
      }

      console.log('tippy setting: ', tippySetting);
      tippyInstance = tippy(btn, tippySetting);
    };

    const init = () => {
      set_tippy();
      new RF_GLOBALS.RfMediaQuery(change_tippy_setting, 'change');
    };

    init();
  };

  // ページトップへ戻る
  const pagetop = () => {

    const pagetop = document.querySelector('[data-js-pagetop]');
    const fps = 10;
    const threshold = 500;
    let prevRenderTime;

    // クリックイベント
    pagetop.addEventListener('click', () => {
      window.scrollTo({top: 0, behavior: 'smooth'});
    });

    // 表示非表示
    const toggleVisibility = (timestamp) => {
      if (!prevRenderTime) {
        prevRenderTime = timestamp - 1000/fps;
      }
      if (timestamp >= prevRenderTime + 1000/fps) {
        pagetop.classList.toggle('--is-show', window.scrollY >= threshold);
        prevRenderTime = timestamp;
      }
      
      requestAnimationFrame(toggleVisibility);
    };

    const init = () => {
      requestAnimationFrame(toggleVisibility);  
    };
    
    init();

  };

  // フェイクAJAX通信whatever..
  const rf_wait = () => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve('wait');
      }, 2000);
    })
  };

  // モーダル処理
  const rf_test = () => {

    // モーダルを開くボタン取得
    const modalOpenBtn = document.querySelector('#ajax-modal-test');

    // モーダルを開く処理
    modalOpenBtn.addEventListener('click', async (e) => {    
      e.preventDefault();

      // ロード中はクリック無効化
      if(e.target.classList.contains('--is-loading')) return

      // ボタンをロード中にdisabled
      e.target.classList.add('--is-loading');

      // ローダーを挿入(画面中央に配置するスタイルを指定)
      const loader = new RF_GLOBALS.RfLoader({
        style: '--bg-black --fixed-center',
      });

      // 2秒待つ(フェイクAJAX通信)
      const res = await rf_wait();
      console.log(res);

      // ローダーを削除
      loader.removeLoader();

      // ボタンからローディングクラスを削除
      e.target.classList.remove('--is-loading');

      // モーダルを開く
      RF_GLOBALS.rf_modals.openModal('#sys-dialog-area');

    });

  };

  // Vendors

  // =======================================================
  // Inits
  const rf_init = () => {

    // Viewport checker (SP or PC)
    rf_responsive_check();

    // グローバル変数、関数、はRF_GLOBALSにまとめ、windowにアサインする
    window['RF_GLOBALS'] = {
      ...window['RF_GLOBALS'],
      RfLoader,
      RfCheckboxStatus,
      RfMediaQuery,
      RfModals,
      rf_modal_madori,
    };

    // rf_set_globals({
    //   window_state: 'PC',
    //   breakpoint: 768,
    // })


    console.log(window['RF_GLOBALS']);


    // Global Navigation
    if (document.querySelector('[data-js-gnav]')) {
      rf_gnav();
    }

    // Toggles
    if (document.querySelector('[data-js-toggle]')) {
      rf_toggles();
    }

    // Pagetop
    if(document.querySelector('[data-js-pagetop]')) {
      pagetop();
    }

    // TOPページ - 本日掲載
    if (document.querySelector('[data-js-today-target]')) {
      rf_todays_count();
    }

    // Topページ - バナー
    if (document.querySelector('[data-js-top-banners]')) {
      console.log('top slider');
      rf_top_banners();
    }

    // 物件スライダー(TOPページ)
    if (document.querySelector('[data-js-prop-slider]')) {
      rf_prop_slider();
    }

    // 物件スライダー(関連）
    if (document.querySelector('[data-js-related-prop-slider]')) {
      rf_related_prop_slider();
    }

    // お部屋リストリンク
    if (document.querySelector('[data-js-room-link]')) {
      rf_room_list_link();
      rf_room_list_toggle();
    }

    // 建物・部屋共通
    // NEW
    let RFtemp;
    if (document.querySelector('[data-js-buildroom-slide]')) {
      RFtemp = new RFBuildroomSlide();
      console.dir(RFtemp);
    }

    // 👇️ OLD
    // if (document.querySelector('[data-js-buildroom-mv]')) {
    //   rf_buildroom_main_slide()
    // }
    // if (document.querySelector('[data-js-buildroom-mv-thumbs]')) {
    //   rf_buildroom_related_slide()
    // }
    //=====

    // モーダル
    if (
      document.querySelector('[data-js-modal]') || //ボタン
      document.querySelector('[data-js-modal-target]') //モーダル本体
    ) {
      RF_GLOBALS.rf_modals = new RF_GLOBALS.RfModals();
    }

    // CTAナビ
    if (document.querySelector('[data-js-cta-navi-tel]')) {
      rf_cta_navi_tel();
    }

    // セレクトリンク
    if (document.querySelector('[data-js-select-link]')) {
      rf_select_link();
    }

    // 区の選択
    if (document.querySelector(`[data-js-ward-select]`)) {
      rf_ward();
    }

    // 検索結果 - お部屋リストスライド
    if (document.querySelector('[data-js-result-room-slide]')) {
      rf_result_room_slide();
    }

    // 検索 - 駅・沿線チェックボックス
    if (document.querySelector('[data-js-form-checkbox]')) {
      rf_search_ensen_checkbox();
    }

    // 検索の方法、選び方の変更
    if (document.querySelector('[data-js-search-change-method]')) {
      rf_search_change_method();
    }

    // TODO: テスト(本番化のときに削除)
    if(document.querySelector('#ajax-modal-test')) {
      rf_test();
    }

    // 間取りモーダル
    if(
      document.querySelector('[data-js-madori-modal]') 
    ) {
      rf_modal_madori();
    }

    // 便利な使い方モーダル
    if( document.querySelector('#modal-convenient-usage')) {
      rf_modal_usage();
    }
  };

  rf_init();

})();
//# sourceMappingURL=rf.min.js.map
